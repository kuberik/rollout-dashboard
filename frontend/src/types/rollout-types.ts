/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = Record<string, never>;
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        KubernetesMetadata: {
            /** @description Name must be unique within a namespace */
            name?: string;
            /** @description Namespace defines the space within which each name must be unique */
            namespace?: string;
            /** @description Annotations is an unstructured key value map stored with a resource */
            annotations?: {
                [key: string]: string;
            };
            /** @description Map of string keys and values that can be used to organize and categorize resources */
            labels?: {
                [key: string]: string;
            };
            /** @description List of objects depended by this object */
            ownerReferences?: {
                /** @description API version of the owner */
                apiVersion?: string;
                /** @description Kind of the owner */
                kind?: string;
                /** @description Name of the owner */
                name?: string;
                /** @description UID of the owner */
                uid?: string;
                /** @description If true, this reference points to the managing controller */
                controller?: boolean;
                /** @description If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed */
                blockOwnerDeletion?: boolean;
            }[];
            /** @description ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow */
            managedFields?: {
                /** @description Manager is an identifier of the workflow managing these fields */
                manager?: string;
                /** @description Operation is the type of operation which lead to this version of the managedFields */
                operation?: string;
                /** @description APIVersion defines the version of this resource that this field set applies to */
                apiVersion?: string;
                /**
                 * Format: date-time
                 * @description Time is timestamp of when these fields were set
                 */
                time?: string;
                /** @description FieldsType is the discriminator for the different fields format and version */
                fieldsType?: string;
                /** @description FieldsV1 holds the field ownership information in a structured format */
                fieldsV1?: Record<string, never>;
            }[];
        };
        /** @description Rollout is the Schema for the rollouts API. */
        Rollout: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description RolloutSpec defines the desired state of Rollout. */
            spec?: {
                /** @description BakeTime specifies how long to wait after bake starts before marking as successful
                 *     If no errors happen within the bake time, the rollout is baked successfully.
                 *     If not specified, no bake time is enforced. */
                bakeTime?: string;
                /** @description DeployTimeout specifies the maximum time to wait for bake to start before marking as failed
                 *     If bake doesn't start within deployTimeout (i.e., health checks don't become healthy),
                 *     the rollout should be marked as failed.
                 *     If not specified, the rollout will wait indefinitely for bake to start. */
                deployTimeout?: string;
                /** @description HealthCheckSelector specifies how to select HealthChecks for this rollout */
                healthCheckSelector?: {
                    /** @description NamespaceSelector specifies the namespace selector for matching HealthChecks
                     *     If not specified, only HealthChecks in the same namespace as the Rollout will be considered */
                    namespaceSelector?: {
                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                        matchExpressions?: {
                            /** @description key is the label key that the selector applies to. */
                            key: string;
                            /** @description operator represents a key's relationship to a set of values.
                             *     Valid operators are In, NotIn, Exists and DoesNotExist. */
                            operator: string;
                            /** @description values is an array of string values. If the operator is In or NotIn,
                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                             *     the values array must be empty. This array is replaced during a strategic
                             *     merge patch. */
                            values?: string[];
                        }[];
                        /** @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                         *     operator is "In", and the values array contains only "value". The requirements are ANDed. */
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                    /** @description Selector specifies the label selector for matching HealthChecks */
                    selector?: {
                        /** @description matchExpressions is a list of label selector requirements. The requirements are ANDed. */
                        matchExpressions?: {
                            /** @description key is the label key that the selector applies to. */
                            key: string;
                            /** @description operator represents a key's relationship to a set of values.
                             *     Valid operators are In, NotIn, Exists and DoesNotExist. */
                            operator: string;
                            /** @description values is an array of string values. If the operator is In or NotIn,
                             *     the values array must be non-empty. If the operator is Exists or DoesNotExist,
                             *     the values array must be empty. This array is replaced during a strategic
                             *     merge patch. */
                            values?: string[];
                        }[];
                        /** @description matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
                         *     map is equivalent to an element of matchExpressions, whose key field is "key", the
                         *     operator is "In", and the values array contains only "value". The requirements are ANDed. */
                        matchLabels?: {
                            [key: string]: string;
                        };
                    };
                };
                /** @description ReleasesImagePolicy specifies the ImagePolicy that provides available releases */
                releasesImagePolicy: {
                    /**
                     * @description Name of the referent.
                     *     This field is effectively required, but due to backwards compatibility is
                     *     allowed to be empty. Instances of this type with an empty value here are
                     *     almost certainly wrong.
                     *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                     * @default
                     */
                    name: string;
                };
                /**
                 * Format: int32
                 * @description VersionHistoryLimit defines the maximum number of entries to keep in the deployment history
                 * @default 5
                 */
                versionHistoryLimit: number;
                /** @description WantedVersion specifies a specific version to deploy, overriding the automatic version selection */
                wantedVersion?: string;
            };
            /** @description RolloutStatus defines the observed state of Rollout. */
            status?: {
                /** @description ArtifactType is the media/artifact type of the image extracted from the manifest.
                 *     This includes OCI artifact types, container image types, and other media types.
                 *     This field is set once for the entire rollout based on the latest available release. */
                artifactType?: string;
                /** @description AvailableReleases is a list of all releases available in the releases repository. */
                availableReleases?: {
                    /**
                     * Format: date-time
                     * @description Created is the creation timestamp extracted from OCI annotations if available.
                     */
                    created?: string;
                    /** @description Digest is the image digest if available from the ImagePolicy. */
                    digest?: string;
                    /** @description Revision is the revision information extracted from OCI annotations if available. */
                    revision?: string;
                    /** @description Tag is the image tag (e.g., "v1.2.3", "latest"). */
                    tag: string;
                    /** @description Version is the semantic version extracted from OCI annotations if available. */
                    version?: string;
                }[];
                /** @description Conditions represents the current state of the rollout process. */
                conditions?: {
                    /**
                     * Format: date-time
                     * @description lastTransitionTime is the last time the condition transitioned from one status to another.
                     *     This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                     */
                    lastTransitionTime: string;
                    /** @description message is a human readable message indicating details about the transition.
                     *     This may be an empty string. */
                    message: string;
                    /**
                     * Format: int64
                     * @description observedGeneration represents the .metadata.generation that the condition was set based upon.
                     *     For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                     *     with respect to the current state of the instance.
                     */
                    observedGeneration?: number;
                    /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                     *     Producers of specific condition types may define expected values and meanings for this field,
                     *     and whether the values are considered a guaranteed API.
                     *     The value should be a CamelCase string.
                     *     This field may not be empty. */
                    reason: string;
                    /**
                     * @description status of the condition, one of True, False, Unknown.
                     * @enum {string}
                     */
                    status: "True" | "False" | "Unknown";
                    /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                    type: string;
                }[];
                /** @description Description is the description of the image extracted from OCI annotations.
                 *     This field is set once for the entire rollout based on the latest available release. */
                description?: string;
                /** @description GatedReleaseCandidates is a list of release candidates that have passed through all gates.
                 *     This shows which versions are actually available for deployment after gate evaluation. */
                gatedReleaseCandidates?: {
                    /**
                     * Format: date-time
                     * @description Created is the creation timestamp extracted from OCI annotations if available.
                     */
                    created?: string;
                    /** @description Digest is the image digest if available from the ImagePolicy. */
                    digest?: string;
                    /** @description Revision is the revision information extracted from OCI annotations if available. */
                    revision?: string;
                    /** @description Tag is the image tag (e.g., "v1.2.3", "latest"). */
                    tag: string;
                    /** @description Version is the semantic version extracted from OCI annotations if available. */
                    version?: string;
                }[];
                /** @description Gates summarizes the status of each gate relevant to this rollout. */
                gates?: {
                    /** @description AllowedVersions is a list of versions that are allowed by the gate. */
                    allowedVersions?: string[];
                    /** @description BypassGates indicates whether this gate was bypassed for the current deployment. */
                    bypassGates?: boolean;
                    /** @description Message is a message describing the status of the gate. */
                    message?: string;
                    /** @description Name is the name of the gate. */
                    name: string;
                    /** @description Passing is true if the gate is passing, false if it is blocking. */
                    passing?: boolean;
                }[];
                /** @description History tracks the deployment history of this Rollout.
                 *     Each entry contains the version deployed and the timestamp of the deployment. */
                history?: {
                    /**
                     * Format: date-time
                     * @description BakeEndTime is the time when the bake period ended for this deployment
                     *     This is when the bake process completed (either successfully or with failure).
                     */
                    bakeEndTime?: string;
                    /**
                     * Format: date-time
                     * @description BakeStartTime is the time when the bake period started for this deployment
                     *     This is when the rollout controller began monitoring the deployment for stability.
                     */
                    bakeStartTime?: string;
                    /** @description BakeStatus tracks the bake state for this deployment (e.g., None, InProgress, Succeeded, Failed, Cancelled)
                     *     The bake process ensures that the deployment is stable and healthy before marking as successful. */
                    bakeStatus?: string;
                    /** @description BakeStatusMessage provides details about the bake state for this deployment
                     *     This field contains human-readable information about why the bake status is what it is. */
                    bakeStatusMessage?: string;
                    /** @description FailedHealthChecks contains all health checks that failed during bake.
                     *     This field is populated when bake fails due to health check errors. */
                    failedHealthChecks?: {
                        /** @description Message is the error message from the health check. */
                        message?: string;
                        /** @description Name is the name of the health check. */
                        name: string;
                        /** @description Namespace is the namespace of the health check. */
                        namespace: string;
                    }[];
                    /**
                     * Format: int64
                     * @description ID is a unique auto-incrementing identifier for this history entry.
                     */
                    id?: number;
                    /** @description Message provides a descriptive message about this deployment entry
                     *     This field contains human-readable information about the deployment context.
                     *     For automatic deployments, it includes information about gate bypass and failed bake unblock.
                     *     For manual deployments (when wantedVersion is specified), it can contain a custom message
                     *     provided via the "rollout.kuberik.com/deployment-message" annotation, or defaults to "Manual deployment". */
                    message?: string;
                    /**
                     * Format: date-time
                     * @description Timestamp is the time when the deployment occurred.
                     */
                    timestamp: string;
                    /** @description Version is the version information that was deployed. */
                    version: {
                        /**
                         * Format: date-time
                         * @description Created is the creation timestamp extracted from OCI annotations if available.
                         */
                        created?: string;
                        /** @description Digest is the image digest if available from the ImagePolicy. */
                        digest?: string;
                        /** @description Revision is the revision information extracted from OCI annotations if available. */
                        revision?: string;
                        /** @description Tag is the image tag (e.g., "v1.2.3", "latest"). */
                        tag: string;
                        /** @description Version is the semantic version extracted from OCI annotations if available. */
                        version?: string;
                    };
                }[];
                /** @description ReleaseCandidates is a list of releases that are candidates for the next deployment.
                 *     These are filtered from AvailableReleases based on deployment history and version ordering. */
                releaseCandidates?: {
                    /**
                     * Format: date-time
                     * @description Created is the creation timestamp extracted from OCI annotations if available.
                     */
                    created?: string;
                    /** @description Digest is the image digest if available from the ImagePolicy. */
                    digest?: string;
                    /** @description Revision is the revision information extracted from OCI annotations if available. */
                    revision?: string;
                    /** @description Tag is the image tag (e.g., "v1.2.3", "latest"). */
                    tag: string;
                    /** @description Version is the semantic version extracted from OCI annotations if available. */
                    version?: string;
                }[];
                /** @description Source is the source information extracted from OCI annotations.
                 *     This typically contains the repository URL or source code location.
                 *     This field is set once for the entire rollout based on the latest available release. */
                source?: string;
                /** @description Title is the title of the image extracted from OCI annotations.
                 *     This field is set once for the entire rollout based on the latest available release. */
                title?: string;
            };
        };
        /** @description RolloutGate is the Schema for the rolloutgates API. */
        RolloutGate: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description RolloutGateSpec defines the desired state of RolloutGate. */
            spec?: {
                /** @description AllowedVersions is a list of versions that Rollout can be updated to. */
                allowedVersions?: string[];
                /**
                 * @description Passing is true if the RolloutGate is passing.
                 * @default true
                 */
                passing: boolean;
                /** @description LocalObjectReference contains enough information to let you locate the
                 *     referenced object inside the same namespace. */
                rolloutRef: {
                    /**
                     * @description Name of the referent.
                     *     This field is effectively required, but due to backwards compatibility is
                     *     allowed to be empty. Instances of this type with an empty value here are
                     *     almost certainly wrong.
                     *     More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                     * @default
                     */
                    name: string;
                };
            };
            /** @description RolloutGateStatus defines the observed state of RolloutGate. */
            status?: Record<string, never>;
        };
        /** @description HealthCheck is the Schema for the healthchecks API. */
        HealthCheck: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description HealthCheckSpec defines the desired state of HealthCheck. */
            spec?: {
                /** @description Class specifies the type of health check (e.g., 'kustomization') */
                class?: string;
            };
            /** @description HealthCheckStatus defines the observed state of HealthCheck. */
            status?: {
                /**
                 * Format: date-time
                 * @description LastChangeTime is the timestamp when the health status last changed
                 */
                lastChangeTime?: string;
                /**
                 * Format: date-time
                 * @description LastErrorTime is the timestamp of the most recent error state
                 */
                lastErrorTime?: string;
                /** @description Message provides additional details about the health status */
                message?: string;
                /** @description Status indicates the health state of the check (e.g., 'Healthy', 'Unhealthy', 'Pending') */
                status?: string;
            };
        };
        /** @description Kustomization is the Schema for the kustomizations API. */
        Kustomization: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description KustomizationSpec defines the configuration to calculate the desired state
             *     from a Source using Kustomize. */
            spec?: {
                /** @description CommonMetadata specifies the common labels and annotations that are
                 *     applied to all resources. Any existing label or annotation will be
                 *     overridden if its key matches a common one. */
                commonMetadata?: {
                    /** @description Annotations to be added to the object's metadata. */
                    annotations?: {
                        [key: string]: string;
                    };
                    /** @description Labels to be added to the object's metadata. */
                    labels?: {
                        [key: string]: string;
                    };
                };
                /** @description Components specifies relative paths to specifications of other Components. */
                components?: string[];
                /** @description Decrypt Kubernetes secrets before applying them on the cluster. */
                decryption?: {
                    /**
                     * @description Provider is the name of the decryption engine.
                     * @enum {string}
                     */
                    provider: "sops";
                    /** @description The secret name containing the private OpenPGP keys used for decryption.
                     *     A static credential for a cloud provider defined inside the Secret
                     *     takes priority to secret-less authentication with the ServiceAccountName
                     *     field. */
                    secretRef?: {
                        /** @description Name of the referent. */
                        name: string;
                    };
                    /** @description ServiceAccountName is the name of the service account used to
                     *     authenticate with KMS services from cloud providers. If a
                     *     static credential for a given cloud provider is defined
                     *     inside the Secret referenced by SecretRef, that static
                     *     credential takes priority. */
                    serviceAccountName?: string;
                };
                /**
                 * @description DeletionPolicy can be used to control garbage collection when this
                 *     Kustomization is deleted. Valid values are ('MirrorPrune', 'Delete',
                 *     'WaitForTermination', 'Orphan'). 'MirrorPrune' mirrors the Prune field
                 *     (orphan if false, delete if true). Defaults to 'MirrorPrune'.
                 * @enum {string}
                 */
                deletionPolicy?: "MirrorPrune" | "Delete" | "WaitForTermination" | "Orphan";
                /** @description DependsOn may contain a meta.NamespacedObjectReference slice
                 *     with references to Kustomization resources that must be ready before this
                 *     Kustomization can be reconciled. */
                dependsOn?: {
                    /** @description Name of the referent. */
                    name: string;
                    /** @description Namespace of the referent, when not specified it acts as LocalObjectReference. */
                    namespace?: string;
                }[];
                /**
                 * @description Force instructs the controller to recreate resources
                 *     when patching fails due to an immutable field change.
                 * @default false
                 */
                force: boolean;
                /** @description HealthCheckExprs is a list of healthcheck expressions for evaluating the
                 *     health of custom resources using Common Expression Language (CEL).
                 *     The expressions are evaluated only when Wait or HealthChecks are specified. */
                healthCheckExprs?: {
                    /** @description APIVersion of the custom resource under evaluation. */
                    apiVersion: string;
                    /** @description Current is the CEL expression that determines if the status
                     *     of the custom resource has reached the desired state. */
                    current: string;
                    /** @description Failed is the CEL expression that determines if the status
                     *     of the custom resource has failed to reach the desired state. */
                    failed?: string;
                    /** @description InProgress is the CEL expression that determines if the status
                     *     of the custom resource has not yet reached the desired state. */
                    inProgress?: string;
                    /** @description Kind of the custom resource under evaluation. */
                    kind: string;
                }[];
                /** @description A list of resources to be included in the health assessment. */
                healthChecks?: {
                    /** @description API version of the referent, if not specified the Kubernetes preferred version will be used. */
                    apiVersion?: string;
                    /** @description Kind of the referent. */
                    kind: string;
                    /** @description Name of the referent. */
                    name: string;
                    /** @description Namespace of the referent, when not specified it acts as LocalObjectReference. */
                    namespace?: string;
                }[];
                /** @description Images is a list of (image name, new name, new tag or digest)
                 *     for changing image names, tags or digests. This can also be achieved with a
                 *     patch, but this operator is simpler to specify. */
                images?: {
                    /** @description Digest is the value used to replace the original image tag.
                     *     If digest is present NewTag value is ignored. */
                    digest?: string;
                    /** @description Name is a tag-less image name. */
                    name: string;
                    /** @description NewName is the value used to replace the original name. */
                    newName?: string;
                    /** @description NewTag is the value used to replace the original tag. */
                    newTag?: string;
                }[];
                /** @description The interval at which to reconcile the Kustomization.
                 *     This interval is approximate and may be subject to jitter to ensure
                 *     efficient use of resources. */
                interval: string;
                /** @description The KubeConfig for reconciling the Kustomization on a remote cluster.
                 *     When used in combination with KustomizationSpec.ServiceAccountName,
                 *     forces the controller to act on behalf of that Service Account at the
                 *     target cluster.
                 *     If the --default-service-account flag is set, its value will be used as
                 *     a controller level fallback for when KustomizationSpec.ServiceAccountName
                 *     is empty. */
                kubeConfig?: {
                    /** @description SecretRef holds the name of a secret that contains a key with
                     *     the kubeconfig file as the value. If no key is set, the key will default
                     *     to 'value'.
                     *     It is recommended that the kubeconfig is self-contained, and the secret
                     *     is regularly updated if credentials such as a cloud-access-token expire.
                     *     Cloud specific `cmd-path` auth helpers will not function without adding
                     *     binaries and credentials to the Pod that is responsible for reconciling
                     *     Kubernetes resources. */
                    secretRef: {
                        /** @description Key in the Secret, when not specified an implementation-specific default key is used. */
                        key?: string;
                        /** @description Name of the Secret. */
                        name: string;
                    };
                };
                /** @description NamePrefix will prefix the names of all managed resources. */
                namePrefix?: string;
                /** @description NameSuffix will suffix the names of all managed resources. */
                nameSuffix?: string;
                /** @description Strategic merge and JSON patches, defined as inline YAML objects,
                 *     capable of targeting objects based on kind, label and annotation selectors. */
                patches?: {
                    /** @description Patch contains an inline StrategicMerge patch or an inline JSON6902 patch with
                     *     an array of operation objects. */
                    patch: string;
                    /** @description Target points to the resources that the patch document should be applied to. */
                    target?: {
                        /** @description AnnotationSelector is a string that follows the label selection expression
                         *     https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
                         *     It matches with the resource annotations. */
                        annotationSelector?: string;
                        /** @description Group is the API group to select resources from.
                         *     Together with Version and Kind it is capable of unambiguously identifying and/or selecting resources.
                         *     https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md */
                        group?: string;
                        /** @description Kind of the API Group to select resources from.
                         *     Together with Group and Version it is capable of unambiguously
                         *     identifying and/or selecting resources.
                         *     https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md */
                        kind?: string;
                        /** @description LabelSelector is a string that follows the label selection expression
                         *     https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
                         *     It matches with the resource labels. */
                        labelSelector?: string;
                        /** @description Name to match resources with. */
                        name?: string;
                        /** @description Namespace to select resources from. */
                        namespace?: string;
                        /** @description Version of the API Group to select resources from.
                         *     Together with Group and Kind it is capable of unambiguously identifying and/or selecting resources.
                         *     https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/api-group.md */
                        version?: string;
                    };
                }[];
                /** @description Path to the directory containing the kustomization.yaml file, or the
                 *     set of plain YAMLs a kustomization.yaml should be generated for.
                 *     Defaults to 'None', which translates to the root path of the SourceRef. */
                path?: string;
                /** @description PostBuild describes which actions to perform on the YAML manifest
                 *     generated by building the kustomize overlay. */
                postBuild?: {
                    /** @description Substitute holds a map of key/value pairs.
                     *     The variables defined in your YAML manifests that match any of the keys
                     *     defined in the map will be substituted with the set value.
                     *     Includes support for bash string replacement functions
                     *     e.g. ${var:=default}, ${var:position} and ${var/substring/replacement}. */
                    substitute?: {
                        [key: string]: string;
                    };
                    /** @description SubstituteFrom holds references to ConfigMaps and Secrets containing
                     *     the variables and their values to be substituted in the YAML manifests.
                     *     The ConfigMap and the Secret data keys represent the var names, and they
                     *     must match the vars declared in the manifests for the substitution to
                     *     happen. */
                    substituteFrom?: {
                        /**
                         * @description Kind of the values referent, valid values are ('Secret', 'ConfigMap').
                         * @enum {string}
                         */
                        kind: "Secret" | "ConfigMap";
                        /** @description Name of the values referent. Should reside in the same namespace as the
                         *     referring resource. */
                        name: string;
                        /**
                         * @description Optional indicates whether the referenced resource must exist, or whether to
                         *     tolerate its absence. If true and the referenced resource is absent, proceed
                         *     as if the resource was present but empty, without any variables defined.
                         * @default false
                         */
                        optional: boolean;
                    }[];
                };
                /** @description Prune enables garbage collection. */
                prune: boolean;
                /** @description The interval at which to retry a previously failed reconciliation.
                 *     When not specified, the controller uses the KustomizationSpec.Interval
                 *     value to retry failures. */
                retryInterval?: string;
                /** @description The name of the Kubernetes service account to impersonate
                 *     when reconciling this Kustomization. */
                serviceAccountName?: string;
                /** @description Reference of the source where the kustomization file is. */
                sourceRef: {
                    /** @description API version of the referent. */
                    apiVersion?: string;
                    /**
                     * @description Kind of the referent.
                     * @enum {string}
                     */
                    kind: "OCIRepository" | "GitRepository" | "Bucket";
                    /** @description Name of the referent. */
                    name: string;
                    /** @description Namespace of the referent, defaults to the namespace of the Kubernetes
                     *     resource object that contains the reference. */
                    namespace?: string;
                };
                /** @description This flag tells the controller to suspend subsequent kustomize executions,
                 *     it does not apply to already started executions. Defaults to false. */
                suspend?: boolean;
                /** @description TargetNamespace sets or overrides the namespace in the
                 *     kustomization.yaml file. */
                targetNamespace?: string;
                /** @description Timeout for validation, apply and health checking operations.
                 *     Defaults to 'Interval' duration. */
                timeout?: string;
                /** @description Wait instructs the controller to check the health of all the reconciled
                 *     resources. When enabled, the HealthChecks are ignored. Defaults to false. */
                wait?: boolean;
            };
            /**
             * @description KustomizationStatus defines the observed state of a kustomization.
             * @default {
             *       "observedGeneration": -1
             *     }
             */
            status: {
                conditions?: {
                    /**
                     * Format: date-time
                     * @description lastTransitionTime is the last time the condition transitioned from one status to another.
                     *     This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                     */
                    lastTransitionTime: string;
                    /** @description message is a human readable message indicating details about the transition.
                     *     This may be an empty string. */
                    message: string;
                    /**
                     * Format: int64
                     * @description observedGeneration represents the .metadata.generation that the condition was set based upon.
                     *     For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                     *     with respect to the current state of the instance.
                     */
                    observedGeneration?: number;
                    /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                     *     Producers of specific condition types may define expected values and meanings for this field,
                     *     and whether the values are considered a guaranteed API.
                     *     The value should be a CamelCase string.
                     *     This field may not be empty. */
                    reason: string;
                    /**
                     * @description status of the condition, one of True, False, Unknown.
                     * @enum {string}
                     */
                    status: "True" | "False" | "Unknown";
                    /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                    type: string;
                }[];
                /** @description Inventory contains the list of Kubernetes resource object references that
                 *     have been successfully applied. */
                inventory?: {
                    /** @description Entries of Kubernetes resource object references. */
                    entries: {
                        /** @description ID is the string representation of the Kubernetes resource object's metadata,
                         *     in the format '<namespace>_<name>_<group>_<kind>'. */
                        id: string;
                        /** @description Version is the API version of the Kubernetes resource object's kind. */
                        v: string;
                    }[];
                };
                /** @description The last successfully applied origin revision.
                 *     Equals the origin revision of the applied Artifact from the referenced Source.
                 *     Usually present on the Metadata of the applied Artifact and depends on the
                 *     Source type, e.g. for OCI it's the value associated with the key
                 *     "org.opencontainers.image.revision". */
                lastAppliedOriginRevision?: string;
                /** @description The last successfully applied revision.
                 *     Equals the Revision of the applied Artifact from the referenced Source. */
                lastAppliedRevision?: string;
                /** @description LastAttemptedRevision is the revision of the last reconciliation attempt. */
                lastAttemptedRevision?: string;
                /** @description LastHandledReconcileAt holds the value of the most recent
                 *     reconcile request value, so a change of the annotation value
                 *     can be detected. */
                lastHandledReconcileAt?: string;
                /**
                 * Format: int64
                 * @description ObservedGeneration is the last reconciled generation.
                 */
                observedGeneration?: number;
            };
        };
        /** @description OCIRepository is the Schema for the ocirepositories API */
        OCIRepository: {
            /** @description APIVersion defines the versioned schema of this representation of an object.
             *     Servers should convert recognized schemas to the latest internal value, and
             *     may reject unrecognized values.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents.
             *     Servers may infer this from the endpoint the client submits requests to.
             *     Cannot be updated.
             *     In CamelCase.
             *     More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description OCIRepositorySpec defines the desired state of OCIRepository */
            spec?: {
                /** @description CertSecretRef can be given the name of a Secret containing
                 *     either or both of
                 *
                 *     - a PEM-encoded client certificate (`tls.crt`) and private
                 *     key (`tls.key`);
                 *     - a PEM-encoded CA certificate (`ca.crt`)
                 *
                 *     and whichever are supplied, will be used for connecting to the
                 *     registry. The client cert and key are useful if you are
                 *     authenticating with a certificate; the CA cert is useful if
                 *     you are using a self-signed server certificate. The Secret must
                 *     be of type `Opaque` or `kubernetes.io/tls`. */
                certSecretRef?: {
                    /** @description Name of the referent. */
                    name: string;
                };
                /** @description Ignore overrides the set of excluded patterns in the .sourceignore format
                 *     (which is the same as .gitignore). If not provided, a default will be used,
                 *     consult the documentation for your version to find out what those are. */
                ignore?: string;
                /** @description Insecure allows connecting to a non-TLS HTTP container registry. */
                insecure?: boolean;
                /** @description Interval at which the OCIRepository URL is checked for updates.
                 *     This interval is approximate and may be subject to jitter to ensure
                 *     efficient use of resources. */
                interval: string;
                /** @description LayerSelector specifies which layer should be extracted from the OCI artifact.
                 *     When not specified, the first layer found in the artifact is selected. */
                layerSelector?: {
                    /** @description MediaType specifies the OCI media type of the layer
                     *     which should be extracted from the OCI Artifact. The
                     *     first layer matching this type is selected. */
                    mediaType?: string;
                    /**
                     * @description Operation specifies how the selected layer should be processed.
                     *     By default, the layer compressed content is extracted to storage.
                     *     When the operation is set to 'copy', the layer compressed content
                     *     is persisted to storage as it is.
                     * @enum {string}
                     */
                    operation?: "extract" | "copy";
                };
                /**
                 * @description The provider used for authentication, can be 'aws', 'azure', 'gcp' or 'generic'.
                 *     When not specified, defaults to 'generic'.
                 * @default generic
                 * @enum {string}
                 */
                provider: "generic" | "aws" | "azure" | "gcp";
                /** @description ProxySecretRef specifies the Secret containing the proxy configuration
                 *     to use while communicating with the container registry. */
                proxySecretRef?: {
                    /** @description Name of the referent. */
                    name: string;
                };
                /** @description The OCI reference to pull and monitor for changes,
                 *     defaults to the latest tag. */
                ref?: {
                    /** @description Digest is the image digest to pull, takes precedence over SemVer.
                     *     The value should be in the format 'sha256:<HASH>'. */
                    digest?: string;
                    /** @description SemVer is the range of tags to pull selecting the latest within
                     *     the range, takes precedence over Tag. */
                    semver?: string;
                    /** @description SemverFilter is a regex pattern to filter the tags within the SemVer range. */
                    semverFilter?: string;
                    /** @description Tag is the image tag to pull, defaults to latest. */
                    tag?: string;
                };
                /** @description SecretRef contains the secret name containing the registry login
                 *     credentials to resolve image metadata.
                 *     The secret must be of type kubernetes.io/dockerconfigjson. */
                secretRef?: {
                    /** @description Name of the referent. */
                    name: string;
                };
                /** @description ServiceAccountName is the name of the Kubernetes ServiceAccount used to authenticate
                 *     the image pull if the service account has attached pull secrets. For more information:
                 *     https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account */
                serviceAccountName?: string;
                /** @description This flag tells the controller to suspend the reconciliation of this source. */
                suspend?: boolean;
                /**
                 * @description The timeout for remote OCI Repository operations like pulling, defaults to 60s.
                 * @default 60s
                 */
                timeout: string;
                /** @description URL is a reference to an OCI artifact repository hosted
                 *     on a remote container registry. */
                url: string;
                /** @description Verify contains the secret name containing the trusted public keys
                 *     used to verify the signature and specifies which provider to use to check
                 *     whether OCI image is authentic. */
                verify?: {
                    /** @description MatchOIDCIdentity specifies the identity matching criteria to use
                     *     while verifying an OCI artifact which was signed using Cosign keyless
                     *     signing. The artifact's identity is deemed to be verified if any of the
                     *     specified matchers match against the identity. */
                    matchOIDCIdentity?: {
                        /** @description Issuer specifies the regex pattern to match against to verify
                         *     the OIDC issuer in the Fulcio certificate. The pattern must be a
                         *     valid Go regular expression. */
                        issuer: string;
                        /** @description Subject specifies the regex pattern to match against to verify
                         *     the identity subject in the Fulcio certificate. The pattern must
                         *     be a valid Go regular expression. */
                        subject: string;
                    }[];
                    /**
                     * @description Provider specifies the technology used to sign the OCI Artifact.
                     * @default cosign
                     * @enum {string}
                     */
                    provider: "cosign" | "notation";
                    /** @description SecretRef specifies the Kubernetes Secret containing the
                     *     trusted public keys. */
                    secretRef?: {
                        /** @description Name of the referent. */
                        name: string;
                    };
                };
            };
            /**
             * @description OCIRepositoryStatus defines the observed state of OCIRepository
             * @default {
             *       "observedGeneration": -1
             *     }
             */
            status: {
                /** @description Artifact represents the output of the last successful OCI Repository sync. */
                artifact?: {
                    /** @description Digest is the digest of the file in the form of '<algorithm>:<checksum>'. */
                    digest?: string;
                    /**
                     * Format: date-time
                     * @description LastUpdateTime is the timestamp corresponding to the last update of the
                     *     Artifact.
                     */
                    lastUpdateTime: string;
                    /** @description Metadata holds upstream information such as OCI annotations. */
                    metadata?: {
                        [key: string]: string;
                    };
                    /** @description Path is the relative file path of the Artifact. It can be used to locate
                     *     the file in the root of the Artifact storage on the local file system of
                     *     the controller managing the Source. */
                    path: string;
                    /** @description Revision is a human-readable identifier traceable in the origin source
                     *     system. It can be a Git commit SHA, Git tag, a Helm chart version, etc. */
                    revision: string;
                    /**
                     * Format: int64
                     * @description Size is the number of bytes in the file.
                     */
                    size?: number;
                    /** @description URL is the HTTP address of the Artifact as exposed by the controller
                     *     managing the Source. It can be used to retrieve the Artifact for
                     *     consumption, e.g. by another controller applying the Artifact contents. */
                    url: string;
                };
                /** @description Conditions holds the conditions for the OCIRepository. */
                conditions?: {
                    /**
                     * Format: date-time
                     * @description lastTransitionTime is the last time the condition transitioned from one status to another.
                     *     This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
                     */
                    lastTransitionTime: string;
                    /** @description message is a human readable message indicating details about the transition.
                     *     This may be an empty string. */
                    message: string;
                    /**
                     * Format: int64
                     * @description observedGeneration represents the .metadata.generation that the condition was set based upon.
                     *     For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
                     *     with respect to the current state of the instance.
                     */
                    observedGeneration?: number;
                    /** @description reason contains a programmatic identifier indicating the reason for the condition's last transition.
                     *     Producers of specific condition types may define expected values and meanings for this field,
                     *     and whether the values are considered a guaranteed API.
                     *     The value should be a CamelCase string.
                     *     This field may not be empty. */
                    reason: string;
                    /**
                     * @description status of the condition, one of True, False, Unknown.
                     * @enum {string}
                     */
                    status: "True" | "False" | "Unknown";
                    /** @description type of condition in CamelCase or in foo.example.com/CamelCase. */
                    type: string;
                }[];
                /** @description LastHandledReconcileAt holds the value of the most recent
                 *     reconcile request value, so a change of the annotation value
                 *     can be detected. */
                lastHandledReconcileAt?: string;
                /**
                 * Format: int64
                 * @description ObservedGeneration is the last observed generation.
                 */
                observedGeneration?: number;
                /** @description ObservedIgnore is the observed exclusion patterns used for constructing
                 *     the source artifact. */
                observedIgnore?: string;
                /** @description ObservedLayerSelector is the observed layer selector used for constructing
                 *     the source artifact. */
                observedLayerSelector?: {
                    /** @description MediaType specifies the OCI media type of the layer
                     *     which should be extracted from the OCI Artifact. The
                     *     first layer matching this type is selected. */
                    mediaType?: string;
                    /**
                     * @description Operation specifies how the selected layer should be processed.
                     *     By default, the layer compressed content is extracted to storage.
                     *     When the operation is set to 'copy', the layer compressed content
                     *     is persisted to storage as it is.
                     * @enum {string}
                     */
                    operation?: "extract" | "copy";
                };
                /** @description URL is the download link for the artifact output of the last OCI Repository sync. */
                url?: string;
            };
        };
        /** @description Rollout is the Schema for the rollouts API */
        KruiseRollout: {
            /** @description APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources */
            apiVersion?: string;
            /** @description Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds */
            kind?: string;
            metadata?: components["schemas"]["KubernetesMetadata"];
            /** @description RolloutSpec defines the desired state of Rollout */
            spec?: {
                /**
                 * @description if a rollout disabled, then the rollout would not watch changes of workload
                 * @default false
                 */
                disabled: boolean;
                /** @description rollout strategy */
                strategy: {
                    /** @description BlueGreenStrategy defines parameters for Blue Green Release */
                    blueGreen?: {
                        /** @description canary service will not be generated if DisableGenerateCanaryService is true */
                        disableGenerateCanaryService?: boolean;
                        /** @description FailureThreshold indicates how many failed pods can be tolerated in all upgraded pods. Only when FailureThreshold are satisfied, Rollout can enter ready state. If FailureThreshold is nil, Rollout will use the MaxUnavailable of workload as its FailureThreshold. Defaults to nil. */
                        failureThreshold?: number | string;
                        /** @description Steps define the order of phases to execute release in batches(20%, 40%, 60%, 80%, 100%) */
                        steps?: {
                            /** @description Matches define conditions used for matching incoming HTTP requests to the canary service. Each match is independent, i.e. this rule will be matched as long as **any** one of the matches is satisfied.
                             *      It cannot support Traffic (weight-based routing) and Matches simultaneously, if both are configured. In such cases, Matches takes precedence. */
                            matches?: {
                                /** @description Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route. */
                                headers?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
                                     *      When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for "Set-Cookie". */
                                    name: string;
                                    /**
                                     * @description Type specifies how to match against the value of the header.
                                     *      Support: Core (Exact)
                                     *      Support: Implementation-specific (RegularExpression)
                                     *      Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
                                     * @default Exact
                                     * @enum {string}
                                     */
                                    type: "Exact" | "RegularExpression";
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                                /** @description Path specifies a HTTP request path matcher. Supported list: - Istio: https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest - GatewayAPI: If path is defined, the whole HttpRouteMatch will be used as a standalone matcher */
                                path?: {
                                    /**
                                     * @description Type specifies how to match against the path Value.
                                     *      Support: Core (Exact, PathPrefix)
                                     *      Support: Implementation-specific (RegularExpression)
                                     * @default PathPrefix
                                     * @enum {string}
                                     */
                                    type: "Exact" | "PathPrefix" | "RegularExpression";
                                    /**
                                     * @description Value of the HTTP path to match against.
                                     * @default /
                                     */
                                    value: string;
                                };
                                /** @description QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Supported list: - Istio: https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest - MSE Ingress: https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/annotations-supported-by-mse-ingress-gateways-1 Header/Cookie > QueryParams - Gateway API */
                                queryParams?: {
                                    /** @description Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3).
                                     *      If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored.
                                     *      If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API.
                                     *      Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations. */
                                    name: string;
                                    /**
                                     * @description Type specifies how to match against the value of the query parameter.
                                     *      Support: Extended (Exact)
                                     *      Support: Implementation-specific (RegularExpression)
                                     *      Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
                                     * @default Exact
                                     * @enum {string}
                                     */
                                    type: "Exact" | "RegularExpression";
                                    /** @description Value is the value of HTTP query param to be matched. */
                                    value: string;
                                }[];
                            }[];
                            /** @description Pause defines a pause stage for a rollout, manual or auto */
                            pause?: {
                                /**
                                 * Format: int32
                                 * @description Duration the amount of time to wait before moving to the next step.
                                 */
                                duration?: number;
                            };
                            /** @description Replicas is the number of expected canary pods in this batch it can be an absolute number (ex: 5) or a percentage of total pods. */
                            replicas?: number | string;
                            /** @description Set overwrites the request with the given header (name, value) before the action.
                             *      Input: GET /foo HTTP/1.1 my-header: foo
                             *      requestHeaderModifier: set: - name: "my-header" value: "bar"
                             *      Output: GET /foo HTTP/1.1 my-header: bar */
                            requestHeaderModifier?: {
                                /** @description Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
                                 *      Input: GET /foo HTTP/1.1 my-header: foo
                                 *      Config: add: - name: "my-header" value: "bar,baz"
                                 *      Output: GET /foo HTTP/1.1 my-header: foo,bar,baz */
                                add?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent. */
                                    name: string;
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                                /** @description Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
                                 *      Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
                                 *      Config: remove: ["my-header1", "my-header3"]
                                 *      Output: GET /foo HTTP/1.1 my-header2: bar */
                                remove?: string[];
                                /** @description Set overwrites the request with the given header (name, value) before the action.
                                 *      Input: GET /foo HTTP/1.1 my-header: foo
                                 *      Config: set: - name: "my-header" value: "bar"
                                 *      Output: GET /foo HTTP/1.1 my-header: bar */
                                set?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent. */
                                    name: string;
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                            };
                            /** @description Traffic indicate how many percentage of traffic the canary pods should receive Value is of string type and is a percentage, e.g. 5%. */
                            traffic?: string;
                        }[];
                        /** @description TrafficRoutingRef is TrafficRouting's Name */
                        trafficRoutingRef?: string;
                        /** @description TrafficRoutings support ingress, gateway api and custom network resource(e.g. istio, apisix) to enable more fine-grained traffic routing and current only support one TrafficRouting */
                        trafficRoutings?: {
                            /** @description CustomNetworkRefs hold a list of custom providers to route traffic */
                            customNetworkRefs?: {
                                /** @description API Version of the referent */
                                apiVersion: string;
                                /** @description Kind of the referent */
                                kind: string;
                                /** @description Name of the referent */
                                name: string;
                            }[];
                            /** @description Gateway holds Gateway specific configuration to route traffic Gateway configuration only supports >= v0.4.0 (v1alpha2). */
                            gateway?: {
                                /** @description HTTPRouteName refers to the name of an `HTTPRoute` resource in the same namespace as the `Rollout` */
                                httpRouteName?: string;
                            };
                            /**
                             * Format: int32
                             * @description Optional duration in seconds the traffic provider(e.g. nginx ingress controller) consumes the service, ingress configuration changes gracefully.
                             * @default 3
                             */
                            gracePeriodSeconds: number;
                            /** @description Ingress holds Ingress specific configuration to route traffic, e.g. Nginx, Alb. */
                            ingress?: {
                                /** @description ClassType refers to the type of `Ingress`. current support nginx, aliyun-alb. default is nginx. */
                                classType?: string;
                                /** @description Name refers to the name of an `Ingress` resource in the same namespace as the `Rollout` */
                                name: string;
                            };
                            /** @description Service holds the name of a service which selects pods with stable version and don't select any pods with canary version. */
                            service: string;
                        }[];
                    };
                    /** @description CanaryStrategy defines parameters for a Replica Based Canary */
                    canary?: {
                        /** @description canary service will not be generated if DisableGenerateCanaryService is true */
                        disableGenerateCanaryService?: boolean;
                        /** @description If true, then it will create new deployment for canary, such as: workload-demo-canary. When user verifies that the canary version is ready, we will remove the canary deployment and release the deployment workload-demo in full. Current only support k8s native deployment */
                        enableExtraWorkloadForCanary?: boolean;
                        /** @description FailureThreshold indicates how many failed pods can be tolerated in all upgraded pods. Only when FailureThreshold are satisfied, Rollout can enter ready state. If FailureThreshold is nil, Rollout will use the MaxUnavailable of workload as its FailureThreshold. Defaults to nil. */
                        failureThreshold?: number | string;
                        /** @description PatchPodTemplateMetadata indicates patch configuration(e.g. labels, annotations) to the canary deployment podTemplateSpec.metadata only support for canary deployment */
                        patchPodTemplateMetadata?: {
                            /** @description annotations */
                            annotations?: {
                                [key: string]: string;
                            };
                            /** @description labels */
                            labels?: {
                                [key: string]: string;
                            };
                        };
                        /** @description Steps define the order of phases to execute release in batches(20%, 40%, 60%, 80%, 100%) */
                        steps?: {
                            /** @description Matches define conditions used for matching incoming HTTP requests to the canary service. Each match is independent, i.e. this rule will be matched as long as **any** one of the matches is satisfied.
                             *      It cannot support Traffic (weight-based routing) and Matches simultaneously, if both are configured. In such cases, Matches takes precedence. */
                            matches?: {
                                /** @description Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route. */
                                headers?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent.
                                     *      When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for "Set-Cookie". */
                                    name: string;
                                    /**
                                     * @description Type specifies how to match against the value of the header.
                                     *      Support: Core (Exact)
                                     *      Support: Implementation-specific (RegularExpression)
                                     *      Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
                                     * @default Exact
                                     * @enum {string}
                                     */
                                    type: "Exact" | "RegularExpression";
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                                /** @description Path specifies a HTTP request path matcher. Supported list: - Istio: https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest - GatewayAPI: If path is defined, the whole HttpRouteMatch will be used as a standalone matcher */
                                path?: {
                                    /**
                                     * @description Type specifies how to match against the path Value.
                                     *      Support: Core (Exact, PathPrefix)
                                     *      Support: Implementation-specific (RegularExpression)
                                     * @default PathPrefix
                                     * @enum {string}
                                     */
                                    type: "Exact" | "PathPrefix" | "RegularExpression";
                                    /**
                                     * @description Value of the HTTP path to match against.
                                     * @default /
                                     */
                                    value: string;
                                };
                                /** @description QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Supported list: - Istio: https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest - MSE Ingress: https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/annotations-supported-by-mse-ingress-gateways-1 Header/Cookie > QueryParams - Gateway API */
                                queryParams?: {
                                    /** @description Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3).
                                     *      If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored.
                                     *      If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API.
                                     *      Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations. */
                                    name: string;
                                    /**
                                     * @description Type specifies how to match against the value of the query parameter.
                                     *      Support: Extended (Exact)
                                     *      Support: Implementation-specific (RegularExpression)
                                     *      Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
                                     * @default Exact
                                     * @enum {string}
                                     */
                                    type: "Exact" | "RegularExpression";
                                    /** @description Value is the value of HTTP query param to be matched. */
                                    value: string;
                                }[];
                            }[];
                            /** @description Pause defines a pause stage for a rollout, manual or auto */
                            pause?: {
                                /**
                                 * Format: int32
                                 * @description Duration the amount of time to wait before moving to the next step.
                                 */
                                duration?: number;
                            };
                            /** @description Replicas is the number of expected canary pods in this batch it can be an absolute number (ex: 5) or a percentage of total pods. */
                            replicas?: number | string;
                            /** @description Set overwrites the request with the given header (name, value) before the action.
                             *      Input: GET /foo HTTP/1.1 my-header: foo
                             *      requestHeaderModifier: set: - name: "my-header" value: "bar"
                             *      Output: GET /foo HTTP/1.1 my-header: bar */
                            requestHeaderModifier?: {
                                /** @description Add adds the given header(s) (name, value) to the request before the action. It appends to any existing values associated with the header name.
                                 *      Input: GET /foo HTTP/1.1 my-header: foo
                                 *      Config: add: - name: "my-header" value: "bar,baz"
                                 *      Output: GET /foo HTTP/1.1 my-header: foo,bar,baz */
                                add?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent. */
                                    name: string;
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                                /** @description Remove the given header(s) from the HTTP request before the action. The value of Remove is a list of HTTP header names. Note that the header names are case-insensitive (see https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
                                 *      Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz
                                 *      Config: remove: ["my-header1", "my-header3"]
                                 *      Output: GET /foo HTTP/1.1 my-header2: bar */
                                remove?: string[];
                                /** @description Set overwrites the request with the given header (name, value) before the action.
                                 *      Input: GET /foo HTTP/1.1 my-header: foo
                                 *      Config: set: - name: "my-header" value: "bar"
                                 *      Output: GET /foo HTTP/1.1 my-header: bar */
                                set?: {
                                    /** @description Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
                                     *      If multiple entries specify equivalent header names, the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, "foo" and "Foo" are considered equivalent. */
                                    name: string;
                                    /** @description Value is the value of HTTP Header to be matched. */
                                    value: string;
                                }[];
                            };
                            /** @description Traffic indicate how many percentage of traffic the canary pods should receive Value is of string type and is a percentage, e.g. 5%. */
                            traffic?: string;
                        }[];
                        /** @description TrafficRoutingRef is TrafficRouting's Name */
                        trafficRoutingRef?: string;
                        /** @description TrafficRoutings support ingress, gateway api and custom network resource(e.g. istio, apisix) to enable more fine-grained traffic routing and current only support one TrafficRouting */
                        trafficRoutings?: {
                            /** @description CustomNetworkRefs hold a list of custom providers to route traffic */
                            customNetworkRefs?: {
                                /** @description API Version of the referent */
                                apiVersion: string;
                                /** @description Kind of the referent */
                                kind: string;
                                /** @description Name of the referent */
                                name: string;
                            }[];
                            /** @description Gateway holds Gateway specific configuration to route traffic Gateway configuration only supports >= v0.4.0 (v1alpha2). */
                            gateway?: {
                                /** @description HTTPRouteName refers to the name of an `HTTPRoute` resource in the same namespace as the `Rollout` */
                                httpRouteName?: string;
                            };
                            /**
                             * Format: int32
                             * @description Optional duration in seconds the traffic provider(e.g. nginx ingress controller) consumes the service, ingress configuration changes gracefully.
                             * @default 3
                             */
                            gracePeriodSeconds: number;
                            /** @description Ingress holds Ingress specific configuration to route traffic, e.g. Nginx, Alb. */
                            ingress?: {
                                /** @description ClassType refers to the type of `Ingress`. current support nginx, aliyun-alb. default is nginx. */
                                classType?: string;
                                /** @description Name refers to the name of an `Ingress` resource in the same namespace as the `Rollout` */
                                name: string;
                            };
                            /** @description Service holds the name of a service which selects pods with stable version and don't select any pods with canary version. */
                            service: string;
                        }[];
                    };
                    /** @description Paused indicates that the Rollout is paused. Default value is false */
                    paused?: boolean;
                };
                /** @description INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file WorkloadRef contains enough information to let you identify a workload for Rollout Batch release of the bypass */
                workloadRef: {
                    /** @description API Version of the referent */
                    apiVersion: string;
                    /** @description Kind of the referent */
                    kind: string;
                    /** @description Name of the referent */
                    name: string;
                };
            };
            /** @description RolloutStatus defines the observed state of Rollout */
            status?: {
                /** @description BlueGreen describes the state of the blueGreen rollout */
                blueGreenStatus?: {
                    /**
                     * Format: int32
                     * @description CurrentStepIndex defines the current step of the rollout is on.
                     */
                    currentStepIndex?: number;
                    currentStepState: string;
                    /** @description FinalisingStep the step of finalising */
                    finalisingStep: string;
                    /** Format: date-time */
                    lastUpdateTime?: string;
                    message?: string;
                    /**
                     * Format: int32
                     * @description NextStepIndex defines the next step of the rollout is on. In normal case, NextStepIndex is equal to CurrentStepIndex + 1 If the current step is the last step, NextStepIndex is equal to -1 Before the release, NextStepIndex is also equal to -1 0 is not used and won't appear in any case It is allowed to patch NextStepIndex by design, e.g. if CurrentStepIndex is 2, user can patch NextStepIndex to 3 (if exists) to achieve batch jump, or patch NextStepIndex to 1 to implement a re-execution of step 1 Patching it with a non-positive value is useless and meaningless, which will be corrected in the next reconciliation
                     */
                    nextStepIndex: number;
                    /** @description ObservedRolloutID will record the newest spec.RolloutID if status.canaryRevision equals to workload.updateRevision */
                    observedRolloutID?: string;
                    /**
                     * Format: int64
                     * @description observedWorkloadGeneration is the most recent generation observed for this Rollout ref workload generation.
                     */
                    observedWorkloadGeneration?: number;
                    /** @description pod template hash is used as service selector label */
                    podTemplateHash: string;
                    /** @description RolloutHash from rollout.spec object */
                    rolloutHash?: string;
                    /** @description StableRevision indicates the revision of stable pods */
                    stableRevision?: string;
                    /**
                     * Format: int32
                     * @description UpdatedReadyReplicas the numbers of updated ready pods
                     */
                    updatedReadyReplicas: number;
                    /**
                     * Format: int32
                     * @description UpdatedReplicas the numbers of updated pods
                     */
                    updatedReplicas: number;
                    /** @description UpdatedRevision is calculated by rollout based on podTemplateHash, and the internal logic flow uses It may be different from rs podTemplateHash in different k8s versions, so it cannot be used as service selector label */
                    updatedRevision: string;
                };
                /** @description Canary describes the state of the canary rollout */
                canaryStatus?: {
                    /**
                     * Format: int32
                     * @description CanaryReadyReplicas the numbers of ready canary revision pods
                     */
                    canaryReadyReplicas: number;
                    /**
                     * Format: int32
                     * @description CanaryReplicas the numbers of canary revision pods
                     */
                    canaryReplicas: number;
                    /** @description CanaryRevision is calculated by rollout based on podTemplateHash, and the internal logic flow uses It may be different from rs podTemplateHash in different k8s versions, so it cannot be used as service selector label */
                    canaryRevision: string;
                    /**
                     * Format: int32
                     * @description CurrentStepIndex defines the current step of the rollout is on.
                     */
                    currentStepIndex?: number;
                    currentStepState: string;
                    /** @description FinalisingStep the step of finalising */
                    finalisingStep: string;
                    /** Format: date-time */
                    lastUpdateTime?: string;
                    message?: string;
                    /**
                     * Format: int32
                     * @description NextStepIndex defines the next step of the rollout is on. In normal case, NextStepIndex is equal to CurrentStepIndex + 1 If the current step is the last step, NextStepIndex is equal to -1 Before the release, NextStepIndex is also equal to -1 0 is not used and won't appear in any case It is allowed to patch NextStepIndex by design, e.g. if CurrentStepIndex is 2, user can patch NextStepIndex to 3 (if exists) to achieve batch jump, or patch NextStepIndex to 1 to implement a re-execution of step 1 Patching it with a non-positive value is useless and meaningless, which will be corrected in the next reconciliation
                     */
                    nextStepIndex: number;
                    /** @description ObservedRolloutID will record the newest spec.RolloutID if status.canaryRevision equals to workload.updateRevision */
                    observedRolloutID?: string;
                    /**
                     * Format: int64
                     * @description observedWorkloadGeneration is the most recent generation observed for this Rollout ref workload generation.
                     */
                    observedWorkloadGeneration?: number;
                    /** @description pod template hash is used as service selector label */
                    podTemplateHash: string;
                    /** @description RolloutHash from rollout.spec object */
                    rolloutHash?: string;
                    /** @description StableRevision indicates the revision of stable pods */
                    stableRevision?: string;
                };
                /** @description Conditions a list of conditions a rollout can have. */
                conditions?: {
                    /**
                     * Format: date-time
                     * @description Last time the condition transitioned from one status to another.
                     */
                    lastTransitionTime?: string;
                    /**
                     * Format: date-time
                     * @description The last time this condition was updated.
                     */
                    lastUpdateTime?: string;
                    /** @description A human readable message indicating details about the transition. */
                    message: string;
                    /** @description The reason for the condition's last transition. */
                    reason: string;
                    /** @description Phase of the condition, one of True, False, Unknown. */
                    status: string;
                    /** @description Type of rollout condition. */
                    type: string;
                }[];
                /**
                 * Format: int32
                 * @description These two values will be synchronized with the same fileds in CanaryStatus or BlueGreeenStatus mainly used to provide info for kubectl get command
                 */
                currentStepIndex: number;
                currentStepState: string;
                /** @description Message provides details on why the rollout is in its current phase */
                message?: string;
                /**
                 * Format: int64
                 * @description observedGeneration is the most recent generation observed for this Rollout.
                 */
                observedGeneration?: number;
                /** @description BlueGreenStatus *BlueGreenStatus `json:"blueGreenStatus,omitempty"` Phase is the rollout phase. */
                phase?: string;
            };
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
