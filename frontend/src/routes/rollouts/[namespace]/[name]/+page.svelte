<script lang="ts">
	import { onMount, onDestroy } from 'svelte';
	import { page } from '$app/stores';
	import type {
		Rollout,
		Kustomization,
		OCIRepository,
		ManagedResourceStatus,
		HealthCheck,
		KruiseRollout
	} from '../../../../types';
	import {
		Card,
		Badge,
		Alert,
		Button,
		Timeline,
		TimelineItem,
		Modal,
		Toast,
		Spinner,
		Tooltip,
		Popover,
		Listgroup,
		ListgroupItem,
		Toggle,
		Clipboard,
		Blockquote,
		Drawer,
		StepIndicator,
		Progressradial,
		Sidebar,
		SidebarGroup,
		SidebarItem
	} from 'flowbite-svelte';
	import {
		CodePullRequestSolid,
		ReplyOutline,
		EditOutline,
		CheckCircleSolid,
		ExclamationCircleSolid,
		InfoCircleSolid,
		CloseOutline,
		CodeOutline,
		DatabaseSolid,
		ClockSolid,
		ClockArrowOutline,
		PauseSolid,
		PlaySolid,
		RefreshOutline,
		CheckOutline,
		ClipboardCleanSolid,
		MessageDotsOutline,
		CalendarWeekSolid,
		QuestionCircleOutline
	} from 'flowbite-svelte-icons';
	import {
		formatTimeAgo,
		formatDuration,
		formatDate,
		getRolloutStatus,
		isFieldManagedByManager,
		isFieldManagedByOtherManager,
		hasBypassGatesAnnotation,
		getBypassGatesVersion,
		getForceDeployVersion,
		hasForceDeployAnnotation,
		isVersionForceDeploying,
		isVersionBypassingGates,
		hasFailedBakeStatus,
		hasUnblockFailedAnnotation,
		getDisplayVersion
	} from '$lib/utils';
	import { now } from '$lib/stores/time';
	import SourceViewer from '$lib/components/SourceViewer.svelte';
	import GitHubViewButton from '$lib/components/GitHubViewButton.svelte';
	import DeployModal from '$lib/components/DeployModal.svelte';
	import ResourceCard from '$lib/components/ResourceCard.svelte';
	import { fly } from 'svelte/transition';

	export let data;
	$: rollout = data.rollout;
	$: loading = data.loading;
	$: error = data.error;

	let kustomizations: Kustomization[] = [];
	let ociRepositories: OCIRepository[] = [];
	let rolloutGates: any[] = [];
	let managedResources: Record<string, ManagedResourceStatus[]> = {};
	let healthChecks: HealthCheck[] = [];
	let hasLoaded = false;

	let annotations: Record<string, Record<string, string>> = {};
	let loadingAnnotations: Record<string, boolean> = {};

	let showPinModal = false;
	let showClearPinModal = false;
	let selectedVersion: string | null = null;

	let showToast = false;
	let toastMessage = '';
	let toastType: 'success' | 'error' = 'success';

	let showRollbackModal = false;
	let rollbackVersion: string | null = null;

	let showResumeRolloutModal = false;
	let showMarkSuccessfulModal = false;
	let markSuccessfulMessage = '';

	// New variables for deploy modal
	let showDeployModal = false;
	let pinVersionToggle = false;
	let deployExplanation = '';
	let deployConfirmationVersion = '';

	// New variables for pin version mode
	let isPinVersionMode = false;

	// Drawer state
	let showTimelineDrawer = false;

	let autoRefreshIntervalId: number | null = null;

	// Toggle for showing/hiding "current" resources

	// Pagination variables
	let currentPage = 1;
	let itemsPerPage = 10;

	// New variables for all repository tags
	let allRepositoryTags: string[] = [];
	let loadingAllTags = false;
	let searchQuery = '';
	let showAllTags = false;
	let clipboardValue = '';

	// Selected version display label (for modal confirmation)
	$: selectedVersionDisplay = (() => {
		if (!selectedVersion) return null;
		const availableRelease = rollout?.status?.availableReleases?.find(
			(ar) => ar.tag === selectedVersion
		);
		if (availableRelease) {
			return getDisplayVersion(availableRelease);
		}
		return selectedVersion;
	})();

	// Function to get gate description from gate annotations
	function getGateDescription(gate: any): string | null {
		// Look for gate description in the gate's own annotations
		return gate.metadata?.annotations?.['gate.kuberik.com/description'] || null;
	}

	// Function to get gate pretty name from gate annotations
	function getGatePrettyName(gate: any): string | null {
		// Look for gate pretty name in the gate's own annotations
		return gate.metadata?.annotations?.['gate.kuberik.com/pretty-name'] || null;
	}

	// Function to get gates blocking a specific version
	function getBlockingGates(version: string): any[] {
		if (!rolloutGates || rolloutGates.length === 0) return [];

		// Filter gates that are blocking this version
		// This is a simplified implementation - you might need to adjust based on your gate data structure
		return rolloutGates.filter((gate) => {
			// Check if this gate is blocking the version
			// This logic might need to be adjusted based on how gates store their blocking information
			const gateStatus = gate.status;
			if (!gateStatus) return false;

			// Check if gate is not passed/approved for this version
			return gateStatus.status !== 'Passed' && gateStatus.status !== 'Approved';
		});
	}

	// Computed property to determine if dashboard is managing the wantedVersion field
	$: isDashboardManagingWantedVersion = (() => {
		if (!rollout) return false;

		// If no wantedVersion is set, dashboard can manage it
		if (rollout.spec?.wantedVersion === undefined) return true;

		// Check if dashboard is managing the wantedVersion field through managedFields
		if (rollout.metadata?.managedFields) {
			if (
				isFieldManagedByManager(
					rollout.metadata.managedFields,
					'rollout-dashboard',
					'spec.wantedVersion'
				)
			) {
				return true;
			}
		}

		// Check if any other manager is managing the wantedVersion field
		if (rollout.metadata?.managedFields) {
			if (
				isFieldManagedByOtherManager(
					rollout.metadata.managedFields,
					'rollout-dashboard',
					'spec.wantedVersion'
				)
			) {
				return false; // Another manager is managing this field
			}
		}

		// Default to allowing management if no conflicts detected
		return true;
	})();

	// Computed property to determine if rollout has an actively pinned version
	$: hasActivelyPinnedVersion = rollout?.spec?.wantedVersion !== undefined;

	// Computed property to determine if pin version toggle should be disabled
	$: isPinVersionToggleDisabled = hasActivelyPinnedVersion;

	// Update pinVersionToggle when rollout state changes
	$: pinVersionToggle = hasActivelyPinnedVersion;

	// Computed property to determine if current version is custom (not in available releases)
	$: isCurrentVersionCustom = (() => {
		if (!rollout?.status?.history?.[0] || !rollout?.status?.availableReleases) return false;
		const currentVersionTag = rollout.status.history[0].version.tag;
		return !rollout.status.availableReleases.some((ar) => ar.tag === currentVersionTag);
	})();

	// Computed properties for pagination
	$: reversedVersions = rollout?.status?.availableReleases
		? [...rollout.status.availableReleases].reverse()
		: [];
	$: totalPages = Math.ceil(reversedVersions.length / itemsPerPage);
	$: paginatedVersions = reversedVersions.slice(
		(currentPage - 1) * itemsPerPage,
		currentPage * itemsPerPage
	);

	// Computed properties for all tags filtering and display
	$: filteredAllTags = allRepositoryTags.filter((tag) =>
		tag.toLowerCase().includes(searchQuery.toLowerCase())
	);
	$: nonStandardTags = allRepositoryTags.filter(
		(tag) => !rollout?.status?.availableReleases?.map((ar) => ar.tag).includes(tag)
	);
	$: filteredNonStandardTags = nonStandardTags.filter((tag) =>
		tag.toLowerCase().includes(searchQuery.toLowerCase())
	);

	// Unified list of all versions for display
	$: allVersionsForDisplay = (() => {
		const availableReleases = rollout?.status?.availableReleases;
		if (!availableReleases) return [];

		// Start with available releases (standard releases)
		const standardReleases = [...availableReleases].reverse();

		// Add additional tags that are not in available releases
		const additionalTags = allRepositoryTags.filter(
			(tag) => !availableReleases.map((ar) => ar.tag).includes(tag)
		);

		// Combine: standard releases first, then additional tags
		return [...standardReleases, ...additionalTags];
	})();

	// Filter the unified list based on search
	$: filteredVersionsForDisplay = allVersionsForDisplay.filter((version) => {
		const versionTag = typeof version === 'string' ? version : version.tag;
		return searchQuery === '' || versionTag.toLowerCase().includes(searchQuery.toLowerCase());
	});

	// Pagination for the unified list
	$: totalUnifiedPages = Math.ceil(filteredVersionsForDisplay.length / itemsPerPage);
	$: paginatedUnifiedVersions = filteredVersionsForDisplay.slice(
		(currentPage - 1) * itemsPerPage,
		currentPage * itemsPerPage
	);

	// Computed property to filter managed resources - now always shows all resources
	$: filteredManagedResources = managedResources;

	function goToPage(page: number) {
		const maxPages = showAllTags ? totalUnifiedPages : totalPages;
		if (page >= 1 && page <= maxPages) {
			currentPage = page;
			selectedVersion = null; // Reset selection when changing pages
		}
	}

	async function updateData() {
		// Wait for rollout to be loaded from layout
		if (!rollout || loading) {
			return;
		}

		try {
			const response = await fetch(`/api/rollouts/${$page.params.namespace}/${$page.params.name}`);
			if (!response.ok) {
				throw new Error('Failed to fetch rollout details');
			}
			const data = await response.json();
			// rollout is already set from parent layout, don't overwrite it
			kustomizations = data.kustomizations?.items || [];
			ociRepositories = data.ociRepositories?.items || [];
			rolloutGates = data.rolloutGates?.items || [];
			console.log('Rollout gates fetched:', rolloutGates);
			console.log('Rollout status gates:', rollout?.status?.gates);

			// if (rollout?.status?.history) {
			// 	// Only fetch annotations for release candidates (custom releases)
			// 	// Regular releases will use .revisions and .version fields from availableReleases
			// 	if (rollout.status.releaseCandidates) {
			// 		const releaseCandidateVersions = rollout.status.releaseCandidates.map((rc) => rc.tag);
			// 		const annotationPromises = releaseCandidateVersions
			// 			.filter((version) => !annotations[version])
			// 			.map((version) => getAnnotations(version));
			// 		await Promise.all(annotationPromises);
			// 	}
			// }

			// Fetch managed resources for each Kustomization
			const tempResources: Record<string, ManagedResourceStatus[]> = {};
			await Promise.all(
				kustomizations
					.filter((kustomization) => Boolean(kustomization.metadata?.name))
					.map(async (kustomization) => {
						const name = kustomization.metadata!.name as string;
						const namespace = kustomization.metadata?.namespace || $page.params.namespace;
						try {
							const resourcesResponse = await fetch(
								`/api/kustomizations/${namespace}/${name}/managed-resources`
							);
							if (resourcesResponse.ok) {
								const resourcesData = await resourcesResponse.json();
								tempResources[name] = resourcesData.managedResources || [];
							}
						} catch (e) {
							console.error(`Failed to fetch managed resources for ${name}:`, e);
						}
					})
			);
			managedResources = tempResources;

			// Fetch health checks that match the rollout's health selector
			if (rollout?.spec?.healthCheckSelector) {
				try {
					const healthChecksResponse = await fetch(
						`/api/rollouts/${$page.params.namespace}/${$page.params.name}/health-checks`
					);
					if (healthChecksResponse.ok) {
						const healthChecksData = await healthChecksResponse.json();
						healthChecks = healthChecksData.healthChecks || [];

						// Log namespace search information
						if (healthChecksData.debug) {
							console.log('Health checks search info:', healthChecksData.debug);
						}
					}
				} catch (e) {
					console.error('Failed to fetch health checks:', e);
				}
			}

			// Clear any previous error on successful fetch
			error = null;
		} catch (e) {
			// Only set error on initial load, preserve stale data on subsequent failed fetches
			if (!hasLoaded) {
				error = e instanceof Error ? e.message : 'Unknown error occurred';
			} else {
				// Log the error but don't show it to the user to preserve stale data
				console.error('Failed to fetch rollout data (preserving stale data):', e);
			}
		} finally {
			// loading is managed by parent layout
		}
	}

	onMount(async () => {
		// Perform initial client-side fetch to avoid SSR relative fetch errors
		if (rollout && !loading && !hasLoaded) {
			await updateData();
			hasLoaded = true;
		}

		autoRefreshIntervalId = window.setInterval(() => {
			updateData();
		}, 5000);
	});

	onDestroy(() => {
		if (autoRefreshIntervalId) {
			clearInterval(autoRefreshIntervalId);
			autoRefreshIntervalId = null;
		}
	});

	async function submitPin(version?: string) {
		const pinVersion = version ?? selectedVersion;
		if (!rollout || !pinVersion) return;

		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/pin`,
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({
						version: pinVersion,
						explanation: deployExplanation
					})
				}
			);

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({}));
				if (
					response.status === 500 &&
					errorData.details &&
					errorData.details.includes('dashboard is not managing the wantedVersion field')
				) {
					throw new Error(
						"Cannot pin version: Dashboard is not managing this rollout's wantedVersion field. This field may be managed by another controller or external system."
					);
				}
				throw new Error('Failed to pin version');
			}

			// Refresh the data
			setTimeout(async () => {
				for (let i = 0; i < 10; i++) {
					await updateData();
					if (rollout?.status?.history?.[0]?.version.tag === pinVersion) {
						break;
					}
				}
			}, 1000);

			// Show success toast
			toastType = 'success';
			toastMessage = `Successfully pinned version`;
			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			// Show error toast
			toastType = 'error';
			toastMessage = e instanceof Error ? e.message : 'Failed to pin version';
			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} finally {
			showPinModal = false;
			selectedVersion = null;
		}
	}

	async function clearPin() {
		if (!rollout) return;

		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/pin`,
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({ version: null })
				}
			);

			if (!response.ok) {
				const errorData = await response.json().catch(() => ({}));
				if (
					response.status === 500 &&
					errorData.details &&
					errorData.details.includes('dashboard is not managing the wantedVersion field')
				) {
					throw new Error(
						"Cannot clear pin: Dashboard is not managing this rollout's wantedVersion field. This field may be managed by another controller or external system."
					);
				}
				throw new Error('Failed to clear version pin');
			}

			// Refresh the data
			await updateData();

			// Show success toast
			toastType = 'success';
			toastMessage = 'Successfully cleared version pin';
			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			// Show error toast
			toastType = 'error';
			toastMessage = e instanceof Error ? e.message : 'Failed to clear version pin';
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} finally {
			showClearPinModal = false;
		}
	}

	async function getAnnotations(version: string) {
		if (!rollout) return;
		loadingAnnotations[version] = true;
		loadingAnnotations = { ...loadingAnnotations };
		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/annotations/${version}`
			);
			if (response.ok) {
				const data = await response.json();
				annotations[version] = data.annotations || {};
			} else {
				annotations[version] = {};
			}
			annotations = { ...annotations };
		} catch (e) {
			console.error(`Failed to fetch annotations for ${version}:`, e);
			annotations[version] = {};
			annotations = { ...annotations };
		} finally {
			loadingAnnotations[version] = false;
			loadingAnnotations = { ...loadingAnnotations };
		}
	}

	// Helper function to get revision information from version object or annotations
	function getRevisionInfo(versionInfo: { revision?: string; tag: string }): string | undefined {
		return versionInfo.revision;
	}

	// Function to load annotations on demand for custom releases when displayed
	async function loadAnnotationsOnDemand(versionTag: string): Promise<void> {
		// Only load if not already loaded and this is not a regular release
		const availableReleaseEntry = rollout?.status?.availableReleases?.find(
			(entry) => entry?.tag === versionTag
		);
		if (!availableReleaseEntry && !annotations[versionTag]) {
			await getAnnotations(versionTag);
		}
	}

	async function getAllRepositoryTags() {
		if (!rollout) return;
		loadingAllTags = true;
		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/tags`
			);
			if (response.ok) {
				const data = await response.json();
				allRepositoryTags = data.tags || [];
			} else {
				allRepositoryTags = [];
			}
		} catch (e) {
			console.error('Failed to fetch repository tags:', e);
			allRepositoryTags = [];
		} finally {
			loadingAllTags = false;
		}
	}

	async function resumeRollout() {
		if (!rollout) return;

		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/unblock-failed`,
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					}
				}
			);

			if (!response.ok) {
				throw new Error('Failed to add unblock-failed annotation');
			}

			await updateData();
			showToast = true;
			toastMessage = 'Rollout resumed successfully';
			toastType = 'success';
			showResumeRolloutModal = false;
			selectedVersion = null;

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			console.error('Failed to resume rollout:', e);
			showToast = true;
			toastMessage = e instanceof Error ? e.message : 'Failed to resume rollout';
			toastType = 'error';

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		}
	}

	async function markDeploymentSuccessful(message: string) {
		if (!rollout) return;

		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/mark-successful`,
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify({ message })
				}
			);

			if (!response.ok) {
				throw new Error('Failed to mark deployment as successful');
			}

			await updateData();
			showToast = true;
			toastMessage = 'Deployment marked as successful';
			toastType = 'success';
			showMarkSuccessfulModal = false;

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			console.error('Failed to mark deployment as successful:', e);
			showToast = true;
			toastMessage = e instanceof Error ? e.message : 'Failed to mark deployment as successful';
			toastType = 'error';

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		}
	}

	async function reconcileFluxResources() {
		if (!rollout) return;

		// Add spinning animation to the icon
		const icon = document.getElementById('reconcile-icon');
		if (icon) {
			icon.classList.add('animate-spin');
			// Remove the spinning class after animation completes
			setTimeout(() => {
				icon.classList.remove('animate-spin');
			}, 1000);
		}

		// Show immediate notification that reconciliation is starting
		showToast = true;
		toastMessage = 'Starting reconciliation of Flux resources...';
		toastType = 'success';

		try {
			const response = await fetch(
				`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/reconcile`,
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					}
				}
			);

			if (!response.ok) {
				throw new Error('Failed to reconcile Flux resources');
			}

			// Show success toast
			showToast = true;
			toastMessage = 'Successfully triggered reconciliation of all associated Flux resources';
			toastType = 'success';

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			console.error('Failed to reconcile Flux resources:', e);
			showToast = true;
			toastMessage = e instanceof Error ? e.message : 'Failed to reconcile Flux resources';
			toastType = 'error';

			// Auto-dismiss toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		}
	}

	async function handleDeploy() {
		if (!rollout || !selectedVersion) return;

		try {
			if (pinVersionToggle) {
				// Use pin version functionality
				const response = await fetch(
					`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/pin`,
					{
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							version: selectedVersion,
							explanation: deployExplanation
						})
					}
				);

				if (!response.ok) {
					const errorData = await response.json().catch(() => ({}));
					if (
						response.status === 500 &&
						errorData.details &&
						errorData.details.includes('dashboard is not managing the wantedVersion field')
					) {
						throw new Error(
							"Cannot pin version: Dashboard is not managing this rollout's wantedVersion field. This field may be managed by another controller or external system."
						);
					}
					throw new Error('Failed to pin version');
				}

				// Refresh the data
				setTimeout(async () => {
					for (let i = 0; i < 10; i++) {
						await updateData();
						if (rollout?.status?.history?.[0]?.version.tag === selectedVersion) {
							break;
						}
					}
				}, 1000);

				// Show success toast
				toastType = 'success';
				toastMessage = `Successfully pinned and deployed version`;
			} else {
				// Use force deploy functionality
				const response = await fetch(
					`/api/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/force-deploy`,
					{
						method: 'POST',
						headers: {
							'Content-Type': 'application/json'
						},
						body: JSON.stringify({
							version: selectedVersion,
							message: deployExplanation
						})
					}
				);

				if (!response.ok) {
					throw new Error('Failed to add force-deploy annotation');
				}

				await updateData();
				toastType = 'success';
				toastMessage = `Force deploy initiated, version rolling out soon`;
			}

			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} catch (e) {
			// Show error toast
			toastType = 'error';
			toastMessage = e instanceof Error ? e.message : 'Failed to deploy version';
			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
		} finally {
			showDeployModal = false;
			selectedVersion = null;
			pinVersionToggle = false;
			deployExplanation = '';
			deployConfirmationVersion = '';
			isPinVersionMode = false;
			showTimelineDrawer = false;
		}
	}

	function formatRevision(revision: string) {
		let result = '';
		if (revision.includes('@sha1:')) {
			result = revision.split('@sha1:')[1];
		} else {
			result = revision;
		}
		return result.substring(0, 7);
	}

	function parseDuration(duration: string): number {
		// Parse Kubernetes duration format (e.g., "5m", "30s", "1h")
		const match = duration.match(/^(\d+)([smhd])$/);
		if (!match) return 0;

		const value = parseInt(match[1]);
		const unit = match[2];

		switch (unit) {
			case 's':
				return value * 1000;
			case 'm':
				return value * 60 * 1000;
			case 'h':
				return value * 60 * 60 * 1000;
			case 'd':
				return value * 24 * 60 * 60 * 1000;
			default:
				return 0;
		}
	}

	function formatDurationFromMs(milliseconds: number): string {
		if (milliseconds <= 0) return '0s';

		const seconds = Math.floor(milliseconds / 1000);
		const minutes = Math.floor(seconds / 60);
		const hours = Math.floor(minutes / 60);
		const days = Math.floor(hours / 24);

		if (days > 0) {
			return `${days}d ${hours % 24}h`;
		} else if (hours > 0) {
			return `${hours}h ${minutes % 60}m`;
		} else if (minutes > 0) {
			return `${minutes}m ${seconds % 60}s`;
		} else {
			return `${seconds}s`;
		}
	}

	function getResourceStatus(resource: Kustomization | OCIRepository) {
		const readyCondition = resource.status?.conditions?.find((c) => c.type === 'Ready');
		if (!readyCondition) return { status: 'Unknown', color: 'gray' as const };

		switch (readyCondition.status) {
			case 'True':
				return { status: 'Ready', color: 'green' as const };
			case 'False':
				return { status: 'Failed', color: 'red' as const };
			default:
				return { status: 'Unknown', color: 'gray' as const };
		}
	}

	function getLastTransitionTime(resource: Kustomization | OCIRepository) {
		const readyCondition = resource.status?.conditions?.find((c) => c.type === 'Ready');
		return readyCondition?.lastTransitionTime;
	}

	function getBakeStatusIcon(bakeStatus?: string) {
		switch (bakeStatus) {
			case 'Succeeded':
				return { icon: CheckCircleSolid, color: 'text-green-600 dark:text-green-400' };
			case 'Failed':
				return { icon: ExclamationCircleSolid, color: 'text-red-600 dark:text-red-400' };
			case 'InProgress':
				return { icon: ClockSolid, color: 'text-yellow-600 dark:text-yellow-400' };
			case 'Cancelled':
				return { icon: CloseOutline, color: 'text-gray-600 dark:text-gray-400' };
			case 'None':
				return { icon: PauseSolid, color: 'text-gray-600 dark:text-gray-400' };
			default:
				return { icon: ClockSolid, color: 'text-gray-600 dark:text-gray-400' };
		}
	}

	function getBakeStatusColor(bakeStatus?: string) {
		switch (bakeStatus) {
			case 'Succeeded':
				return 'bg-green-200 dark:bg-green-900';
			case 'Failed':
				return 'bg-red-200 dark:bg-red-900';
			case 'InProgress':
				return 'bg-yellow-200 dark:bg-yellow-900';
			case 'Cancelled':
				return 'bg-gray-200 dark:bg-gray-700';
			case 'None':
				return 'bg-gray-200 dark:bg-gray-700';
			default:
				return 'bg-gray-200 dark:bg-gray-700';
		}
	}

	async function continueRollout(rolloutName: string, namespace: string) {
		try {
			const response = await fetch(`/api/rollouts/${namespace}/${rolloutName}/continue`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify({
					currentStepState: 'StepReady'
				})
			});

			if (!response.ok) {
				throw new Error('Failed to continue rollout');
			}

			showToast = true;
			toastMessage = `Successfully continued rollout ${rolloutName}`;
			toastType = 'success';

			// Auto-hide toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);

			// Refresh the rollout data
			await updateData();
		} catch (error) {
			console.error('Continue rollout error:', error);
			showToast = true;
			toastMessage = `Failed to continue rollout: ${error instanceof Error ? error.message : 'Unknown error'}`;
			toastType = 'error';

			// Auto-hide toast after 3 seconds
			setTimeout(() => {
				showToast = false;
			}, 3000);
		}
	}
</script>

<svelte:head>
	<title
		>kuberik | {rollout?.metadata
			? `${rollout.metadata.name} (${rollout.metadata.namespace})`
			: 'Rollout'}</title
	>
</svelte:head>

<div class="h-full w-full dark:bg-gray-900">
	{#if loading}
		<div class="space-y-4 p-4">
			<div class="w-full">
				<div class="h-8 w-48 animate-pulse rounded bg-gray-200 dark:bg-gray-700"></div>
			</div>
			<div class="grid gap-4">
				{#each Array(3) as _}
					<div class="w-full">
						<div class="h-16 w-full animate-pulse rounded bg-gray-200 dark:bg-gray-700"></div>
					</div>
				{/each}
			</div>
		</div>
	{:else if error}
		<Alert color="red" class="mb-4">
			{error}
		</Alert>
	{:else if !rollout}
		<Alert color="yellow" class="mb-4">Release not found</Alert>
	{:else}
		<!-- Main Layout: Sidebar and content side by side -->
		<div class="flex h-full overflow-hidden">
			<!-- Content -->
			<div class="flex flex-1 flex-col overflow-hidden">
				<!-- Content Area -->
				<div class="flex-1 overflow-y-auto p-4">
					<!-- Failed Deployment Alert -->
					{#if rollout && hasFailedBakeStatus(rollout) && !hasUnblockFailedAnnotation(rollout)}
						<Alert color="gray" class="border-1 mb-4 border-red-600 dark:border-red-400">
							<div class="flex items-center gap-3">
								<ExclamationCircleSolid class="h-5 w-5 text-red-600 dark:text-red-400" />
								<span class="text-lg font-medium text-red-600 dark:text-red-400"
									>Deployment Failed</span
								>
							</div>
							<p class="mb-4 mt-2 text-sm">
								The latest deployment has failed. You can resume the rollout, mark it as successful,
								or deploy another version to fix the issue.
							</p>
							<div class="flex gap-2">
								<Button
									size="xs"
									color="light"
									onclick={() => {
										selectedVersion = rollout?.status?.history?.[0]?.version.tag || null;
										showResumeRolloutModal = true;
									}}
								>
									<PlaySolid class="me-2 h-4 w-4" />
									Resume Rollout
								</Button>
								<Button
									size="xs"
									outline
									color="light"
									onclick={() => {
										selectedVersion = rollout?.status?.history?.[0]?.version.tag || null;
										showMarkSuccessfulModal = true;
									}}
								>
									<CheckCircleSolid class="me-2 h-4 w-4" />
									Mark Successful
								</Button>
							</div>
						</Alert>
					{/if}

					<!-- Dashboard Grid -->
					<div class="grid w-full grid-cols-1 gap-4 lg:grid-cols-2 xl:grid-cols-2">
						<!-- Current Version Card -->
						{#if rollout.status?.history?.[0]}
							{@const latestEntry = rollout.status.history[0]}
							<Card class="w-full max-w-none p-6 lg:col-span-2">
								<!-- Header Section -->
								<div class="mb-6">
									<div class="flex items-center justify-between">
										<h3 class="text-xl font-bold text-gray-900 dark:text-white">Current Version</h3>
										<div class="flex items-center gap-2 text-sm text-gray-500 dark:text-gray-400">
											<ClockSolid class="h-4 w-4" />
											<span>Deployed {formatTimeAgo(latestEntry.timestamp, $now)}</span>
										</div>
									</div>
								</div>

								<!-- Version Display Section -->
								<div class="mb-6">
									<div class="flex items-center gap-4">
										<!-- Status Icon -->
										<div
											class="flex h-12 w-12 items-center justify-center rounded-full bg-gray-100 dark:bg-gray-800"
										>
											{#if latestEntry.bakeStatus === 'InProgress'}
												<Spinner color="yellow" size="6" />
											{:else}
												<svelte:component
													this={getBakeStatusIcon(latestEntry.bakeStatus).icon}
													class="h-6 w-6 {getBakeStatusIcon(latestEntry.bakeStatus).color}"
												/>
											{/if}
										</div>

										<!-- Version Info -->
										<div class="flex-1">
											<h4 class="text-2xl font-bold text-gray-900 dark:text-white">
												{getDisplayVersion(latestEntry.version)}
											</h4>
											<div class="mt-1 flex items-center gap-2">
												{#if getRevisionInfo(latestEntry.version)}
													<Badge color="blue" size="small">
														{formatRevision(getRevisionInfo(latestEntry.version)!)}
													</Badge>
												{/if}
												{#if isCurrentVersionCustom}
													<Badge color="yellow" size="small">Custom</Badge>
												{/if}
												<Badge
													color={latestEntry.bakeStatus === 'Succeeded'
														? 'green'
														: latestEntry.bakeStatus === 'Failed'
															? 'red'
															: 'yellow'}
													size="small"
												>
													{latestEntry.bakeStatus}
												</Badge>
											</div>
										</div>
									</div>
								</div>

								<!-- Deployment Timeline -->
								<div class="mb-6">
									<h5 class="mb-4 text-sm font-semibold text-gray-700 dark:text-gray-300">
										Deployment Timeline
									</h5>

									<Timeline order="horizontal" class="w-full">
										<!-- Started -->
										<TimelineItem
											title="Started"
											date={formatTimeAgo(latestEntry.timestamp, $now)}
											class="min-w-0 flex-1 pr-3"
										>
											{#snippet orientationSlot()}
												<div class="flex items-center">
													<div
														class="z-10 flex h-6 w-6 shrink-0 items-center justify-center rounded-full bg-blue-200 ring-0 ring-white sm:ring-8 dark:bg-blue-900 dark:ring-gray-800"
													>
														<ClockSolid class="h-4 w-4 text-blue-600 dark:text-blue-400" />
													</div>
													<div
														class="hidden h-0.5 w-full bg-gray-200 sm:flex dark:bg-gray-700"
													></div>
												</div>
											{/snippet}
											{#if latestEntry.message}
												<Blockquote
													class="mt-2 break-words text-sm text-gray-600 dark:text-gray-400"
												>
													"{latestEntry.message}"
												</Blockquote>
											{/if}
										</TimelineItem>

										<!-- OpenKruise Rollout Progress (during baking and after completion) -->
										{@const openKruiseRollouts = Object.values(managedResources)
											.flat()
											.filter(
												(resource) =>
													resource.groupVersionKind === 'rollouts.kruise.io/v1beta1/Rollout'
											)}
										{#if openKruiseRollouts.length > 0 && (latestEntry.bakeStatus === 'InProgress' || latestEntry.bakeStatus === 'Succeeded')}
											{#each openKruiseRollouts as rolloutResource}
												{@const kruiseRollout = rolloutResource.object as KruiseRollout}
												{@const rolloutData = kruiseRollout?.status?.canaryStatus}
												{@const canarySteps = kruiseRollout?.spec?.strategy?.canary?.steps}
												{#if rolloutData && canarySteps && canarySteps.length > 0}
													{@const isCompleted =
														rolloutData.currentStepState === 'Completed' &&
														latestEntry.bakeStatus === 'Succeeded'}
													<TimelineItem
														title="Rollout Progress"
														date="Step {rolloutData.currentStepIndex || 1} of {canarySteps.length}"
														class="min-w-0 flex-1 pr-3"
													>
														{#snippet orientationSlot()}
															<div class="flex items-center">
																<div
																	class="z-10 flex h-6 w-6 shrink-0 items-center justify-center rounded-full ring-0 ring-white sm:ring-8 dark:ring-gray-800 {rolloutData.currentStepState ===
																	'Completed'
																		? 'bg-green-200 dark:bg-green-900'
																		: rolloutData.currentStepState === 'StepPaused'
																			? 'bg-yellow-200 dark:bg-yellow-900'
																			: 'bg-blue-200 dark:bg-blue-900'}"
																>
																	{#if rolloutData.currentStepState === 'Completed'}
																		<CheckCircleSolid
																			class="h-4 w-4 text-green-600 dark:text-green-400"
																		/>
																	{:else if rolloutData.currentStepState === 'StepPaused'}
																		<PauseSolid
																			class="h-4 w-4 text-yellow-600 dark:text-yellow-400"
																		/>
																	{:else}
																		<Spinner size="4" color="blue" />
																	{/if}
																</div>
																<div
																	class="hidden h-0.5 w-full bg-gray-200 sm:flex dark:bg-gray-700"
																></div>
															</div>
														{/snippet}
														<div class="mt-2 space-y-2">
															<div class="flex items-center justify-between gap-2">
																<div class="flex items-center gap-2">
																	<Badge
																		color={rolloutData.currentStepState === 'Completed'
																			? 'green'
																			: rolloutData.currentStepState === 'StepPaused'
																				? 'yellow'
																				: 'blue'}
																		size="small"
																	>
																		{rolloutData.currentStepState === 'Completed'
																			? 'Completed'
																			: rolloutData.currentStepState === 'StepPaused'
																				? 'Paused'
																				: 'In Progress'}
																	</Badge>
																	{#if rolloutResource.namespace}
																		<span class="text-xs text-gray-500 dark:text-gray-400">
																			{rolloutResource.namespace} /
																		</span>
																	{/if}
																	<span
																		class="text-xs font-medium text-gray-700 dark:text-gray-300"
																	>
																		{rolloutResource.name}
																	</span>
																</div>
																{#if rolloutData.currentStepState === 'StepPaused'}
																	<Button
																		size="xs"
																		color="blue"
																		onclick={() =>
																			continueRollout(
																				rolloutResource.name,
																				rolloutResource.namespace
																			)}
																	>
																		<PlaySolid class="mr-1 h-3 w-3" />
																		Continue
																	</Button>
																{/if}
															</div>
															{#if !isCompleted}
																<StepIndicator
																	glow
																	currentStep={(rolloutData.currentStepIndex || 1) +
																		(rolloutData.currentStepState === 'Completed' ? 1 : 0)}
																	steps={canarySteps.map((step: any, index: number) =>
																		index === canarySteps.length - 1 &&
																		rolloutData.currentStepState === 'Completed'
																			? 'Completed'
																			: `Step ${index + 1}`
																	)}
																	color="blue"
																	size="sm"
																/>
															{/if}
														</div>
													</TimelineItem>
												{/if}
											{/each}
										{/if}

										<!-- Deployed -->
										{#if latestEntry.bakeStatus === 'Succeeded' && latestEntry.bakeStartTime && latestEntry.bakeEndTime}
											<TimelineItem
												title="Deployed"
												date={formatTimeAgo(latestEntry.bakeEndTime, $now)}
												class="min-w-0 flex-1 pr-3"
											>
												{#snippet orientationSlot()}
													<div class="flex items-center">
														<div
															class="z-10 flex h-6 w-6 shrink-0 items-center justify-center rounded-full bg-green-200 ring-0 ring-white sm:ring-8 dark:bg-green-900 dark:ring-gray-800"
														>
															<CheckCircleSolid
																class="h-4 w-4 text-green-600 dark:text-green-400"
															/>
														</div>
														<div
															class="hidden h-0.5 w-full bg-gray-200 sm:flex dark:bg-gray-700"
														></div>
													</div>
												{/snippet}
												<div class="mt-1 text-sm text-gray-600 dark:text-gray-400">
													Completed after {formatDuration(
														latestEntry.bakeStartTime,
														new Date(latestEntry.bakeEndTime)
													)}
													{#if latestEntry.bakeStatusMessage}
														<br />
														{latestEntry.bakeStatusMessage}
													{/if}
												</div>
											</TimelineItem>
										{:else if latestEntry.bakeStatus === 'Failed' && latestEntry.bakeStartTime && latestEntry.bakeEndTime}
											<TimelineItem
												title="Deployment failed"
												date={formatTimeAgo(latestEntry.bakeEndTime, $now)}
												class="min-w-0 flex-1 pr-3"
											>
												{#snippet orientationSlot()}
													<div class="flex items-center">
														<div
															class="z-10 flex h-6 w-6 shrink-0 items-center justify-center rounded-full bg-red-200 ring-0 ring-white sm:ring-8 dark:bg-red-900 dark:ring-gray-800"
														>
															<ExclamationCircleSolid
																class="h-4 w-4 text-red-600 dark:text-red-400"
															/>
														</div>
														<div
															class="hidden h-0.5 w-full bg-gray-200 sm:flex dark:bg-gray-700"
														></div>
													</div>
												{/snippet}
												<div class="mt-1 text-sm text-gray-600 dark:text-gray-400">
													Failed after {formatDuration(
														latestEntry.bakeStartTime,
														new Date(latestEntry.bakeEndTime)
													)}
													{#if latestEntry.bakeStatusMessage}
														<br />
														{latestEntry.bakeStatusMessage}
													{/if}
												</div>
											</TimelineItem>
										{:else if latestEntry.bakeStatus === 'InProgress'}
											<TimelineItem
												title="Baking..."
												date={rollout.spec?.minBakeTime
													? (() => {
															const deploymentTime = new Date(latestEntry.timestamp).getTime();
															const currentTime = $now.getTime();
															const elapsedTime = currentTime - deploymentTime;
															const minBakeTimeMs = parseDuration(rollout.spec.minBakeTime);
															const maxBakeTimeMs = rollout.spec.maxBakeTime
																? parseDuration(rollout.spec.maxBakeTime)
																: null;
															if (elapsedTime < minBakeTimeMs) {
																const remainingTime = minBakeTimeMs - elapsedTime;
																return `Waiting to mark the deployment as successful for at least ${formatDurationFromMs(remainingTime)}`;
															} else if (maxBakeTimeMs) {
																const timeoutTime = deploymentTime + maxBakeTimeMs;
																const timeUntilTimeout = timeoutTime - currentTime;
																return `Will mark deployment as failed if health checks don't pass in ${formatDurationFromMs(Math.max(timeUntilTimeout, 0))}`;
															} else {
																return 'Waiting for health checks to pass...';
															}
														})()
													: 'Waiting for deployment to complete...'}
												class="min-w-0 flex-1 pr-3"
											>
												{#snippet orientationSlot()}
													<div class="flex items-center">
														<div
															class="z-10 flex h-6 w-6 shrink-0 items-center justify-center rounded-full ring-0 ring-white sm:ring-8 dark:ring-gray-800 {latestEntry.bakeStatus ===
															'InProgress'
																? 'bg-yellow-200 dark:bg-yellow-900'
																: healthChecks.every((hc) => hc.status?.status === 'Healthy')
																	? 'bg-green-200 dark:bg-green-900'
																	: healthChecks.some((hc) => hc.status?.status === 'Unhealthy')
																		? 'bg-red-200 dark:bg-red-900'
																		: 'bg-yellow-200 dark:bg-yellow-900'}"
														>
															{#if latestEntry.bakeStatus === 'InProgress'}
																<Spinner size="4" color="yellow" />
															{:else if healthChecks.every((hc) => hc.status?.status === 'Healthy')}
																<CheckCircleSolid
																	class="h-4 w-4 text-green-600 dark:text-green-400"
																/>
															{:else if healthChecks.some((hc) => hc.status?.status === 'Unhealthy')}
																<ExclamationCircleSolid
																	class="h-4 w-4 text-red-600 dark:text-red-400"
																/>
															{:else}
																<ClockSolid class="h-4 w-4 text-yellow-600 dark:text-yellow-400" />
															{/if}
														</div>
														<div
															class="hidden h-0.5 w-full bg-gray-200 sm:flex dark:bg-gray-700"
														></div>
													</div>
												{/snippet}
												<div class="mt-1 text-sm text-gray-600 dark:text-gray-400">
													{latestEntry.bakeStatusMessage || 'Baking in progress...'}
												</div>
												<div></div>
											</TimelineItem>
										{/if}
									</Timeline>
								</div>

								<!-- Action Buttons -->
								<div class="flex flex-wrap gap-3">
									<Button
										size="sm"
										color="light"
										class="text-xs"
										disabled={!isDashboardManagingWantedVersion}
										onclick={() => {
											if (isDashboardManagingWantedVersion) {
												isPinVersionMode = true;
												showPinModal = true;
											}
										}}
									>
										<EditOutline class="me-2 h-4 w-4" />
										Pin Version
									</Button>
									{#if !isDashboardManagingWantedVersion}
										<Tooltip placement="bottom"
											>Version management disabled: This rollout's wantedVersion field is managed by
											another controller or external system. The dashboard cannot pin it to prevent
											conflicts.</Tooltip
										>
									{/if}
									{#if rollout.spec?.wantedVersion}
										<Button
											size="sm"
											color="light"
											class="text-xs"
											disabled={!isDashboardManagingWantedVersion}
											onclick={() => {
												if (isDashboardManagingWantedVersion) {
													showClearPinModal = true;
												}
											}}
										>
											<CloseOutline class="me-2 h-4 w-4" />
											Clear Pin
										</Button>
										{#if !isDashboardManagingWantedVersion}
											<Tooltip placement="bottom"
												>Version management disabled: This rollout's wantedVersion field is managed
												by another controller or external system. The dashboard cannot pin it to
												prevent conflicts.</Tooltip
											>
										{/if}
									{/if}
									{#if rollout?.status?.artifactType === 'application/vnd.cncf.flux.config.v1+json'}
										<SourceViewer
											namespace={rollout.metadata?.namespace || ''}
											name={rollout.metadata?.name || ''}
											version={latestEntry.version.tag}
										/>
									{/if}
									{#if rollout?.status?.source}
										<GitHubViewButton
											sourceUrl={rollout.status.source}
											version={getDisplayVersion(latestEntry.version)}
											size="sm"
											color="light"
										/>
									{/if}
								</div>
							</Card>
						{/if}

						<!-- Health Checks Card -->
						{#if healthChecks.length > 0}
							<Card class="w-full max-w-none p-6">
								<div class="mb-4 flex items-center justify-between">
									<h4 class="text-lg font-medium text-gray-900 dark:text-white">Health Checks</h4>
									<div class="flex items-center gap-2">
										<Badge color="blue" size="small">
											{healthChecks.filter((hc) => hc.status?.status === 'Healthy')
												.length}/{healthChecks.length} healthy
										</Badge>
									</div>
								</div>
								{#if healthChecks.filter((hc) => hc.status?.status !== 'Healthy').length > 0}
									<div class="space-y-0">
										{#each healthChecks.filter((hc) => hc.status?.status !== 'Healthy') as healthCheck (healthCheck.metadata?.name + '/' + healthCheck.metadata?.namespace)}
											<div
												class="border-b border-gray-200 py-4 last:border-b-0 dark:border-gray-700"
											>
												<div class="flex items-center justify-between">
													<div class="flex items-center gap-3">
														<div class="flex h-8 w-8 items-center justify-center">
															{#if healthCheck.status?.status === 'Healthy'}
																<CheckCircleSolid
																	class="h-5 w-5 text-green-600 dark:text-green-400"
																/>
															{:else if healthCheck.status?.status === 'Unhealthy'}
																<ExclamationCircleSolid
																	class="h-5 w-5 text-red-600 dark:text-red-400"
																/>
															{:else if healthCheck.status?.status === 'Pending'}
																<Spinner size="6" color="yellow" />
															{:else}
																<ExclamationCircleSolid
																	class="h-5 w-5 text-gray-500 dark:text-gray-400"
																/>
															{/if}
														</div>
														<div class="min-w-0 flex-1">
															<h3
																class="truncate text-sm font-medium text-gray-900 dark:text-white"
															>
																{healthCheck.metadata?.annotations?.['kuberik.com/display-name'] ||
																	healthCheck.metadata?.name}
															</h3>
															{#if healthCheck.spec?.class}
																<p class="text-xs text-gray-500 dark:text-gray-400">
																	{healthCheck.spec.class.charAt(0).toUpperCase() +
																		healthCheck.spec.class.slice(1)}
																</p>
															{/if}
														</div>
													</div>
													<div class="flex items-center gap-2">
														{#if healthCheck.status?.lastChangeTime}
															<div class="text-xs text-gray-500 dark:text-gray-400">
																{formatTimeAgo(healthCheck.status.lastChangeTime, $now)}
															</div>
														{/if}
														<Badge
															color={healthCheck.status?.status === 'Healthy'
																? 'green'
																: healthCheck.status?.status === 'Unhealthy'
																	? 'red'
																	: 'yellow'}
															size="small"
															class="cursor-help"
														>
															{healthCheck.status?.status || 'Unknown'}
														</Badge>
														<Popover class="max-w-sm">
															<div class="p-4">
																<div class="mb-3">
																	<div class="mb-2 flex items-center gap-2">
																		{#if healthCheck.status?.status === 'Healthy'}
																			<CheckCircleSolid
																				class="h-4 w-4 text-green-600 dark:text-green-400"
																			/>
																		{:else if healthCheck.status?.status === 'Unhealthy'}
																			<ExclamationCircleSolid
																				class="h-4 w-4 text-red-600 dark:text-red-400"
																			/>
																		{:else if healthCheck.status?.status === 'Pending'}
																			<Spinner size="4" color="yellow" />
																		{:else}
																			<ExclamationCircleSolid
																				class="h-4 w-4 text-gray-500 dark:text-gray-400"
																			/>
																		{/if}
																		<h4 class="text-sm font-semibold text-gray-900 dark:text-white">
																			{healthCheck.metadata?.annotations?.[
																				'kuberik.com/display-name'
																			] || healthCheck.metadata?.name}
																		</h4>
																	</div>
																	<Badge
																		color={healthCheck.status?.status === 'Healthy'
																			? 'green'
																			: healthCheck.status?.status === 'Unhealthy'
																				? 'red'
																				: 'yellow'}
																		size="small"
																		class="text-xs"
																	>
																		{healthCheck.status?.status || 'Unknown'}
																	</Badge>
																</div>

																{#if healthCheck.status?.message}
																	<div class="mb-3 rounded-lg bg-gray-50 p-3 dark:bg-gray-800">
																		<p
																			class="text-xs leading-relaxed text-gray-700 dark:text-gray-300"
																		>
																			{healthCheck.status.message}
																		</p>
																	</div>
																{/if}

																<div class="space-y-2 text-xs">
																	{#if healthCheck.status?.lastErrorTime && healthCheck.status?.status === 'Unhealthy'}
																		<div
																			class="flex items-center gap-2 text-red-600 dark:text-red-400"
																		>
																			<ClockSolid class="h-3 w-3" />
																			<span
																				>Last Error: {formatTimeAgo(
																					healthCheck.status.lastErrorTime,
																					$now
																				)}</span
																			>
																		</div>
																	{/if}
																	{#if healthCheck.spec?.class}
																		<div
																			class="flex items-center gap-2 text-gray-600 dark:text-gray-400"
																		>
																			<DatabaseSolid class="h-3 w-3" />
																			<span
																				>Class: {healthCheck.spec.class.charAt(0).toUpperCase() +
																					healthCheck.spec.class.slice(1)}</span
																			>
																		</div>
																	{/if}
																	{#if healthCheck.status?.lastChangeTime}
																		<div
																			class="flex items-center gap-2 text-gray-600 dark:text-gray-400"
																		>
																			<ClockSolid class="h-3 w-3" />
																			<span
																				>Last Change: {formatTimeAgo(
																					healthCheck.status.lastChangeTime,
																					$now
																				)}</span
																			>
																		</div>
																	{/if}
																</div>
															</div>
														</Popover>
													</div>
												</div>

												{#if healthCheck.status?.message}
													<div class="ml-11 mt-2">
														<p class="mb-1 text-xs text-gray-600 dark:text-gray-400">
															{healthCheck.status.message}
														</p>
													</div>
												{/if}
												{#if healthCheck.status?.lastErrorTime && healthCheck.status?.status === 'Unhealthy'}
													<div class="ml-11 mt-1">
														<div
															class="flex items-center gap-1 text-xs text-red-600 dark:text-red-400"
														>
															<ExclamationCircleSolid class="h-3 w-3" />
															<span
																>Error {formatTimeAgo(healthCheck.status.lastErrorTime, $now)}</span
															>
														</div>
													</div>
												{/if}
											</div>
										{/each}
									</div>
								{:else}
									<div class="flex items-center justify-center py-8">
										<div class="text-center">
											<div class="mb-2 flex items-center justify-center">
												<CheckCircleSolid class="h-8 w-8 text-green-600 dark:text-green-400" />
											</div>
											<p class="text-sm font-medium text-gray-900 dark:text-white">
												All {healthChecks.length} health checks are healthy
											</p>
										</div>
									</div>
								{/if}
							</Card>
						{/if}

						<!-- Kubernetes Resources Status Card -->
						{#if kustomizations.length > 0 || ociRepositories.length > 0 || (managedResources && Object.keys(managedResources).length > 0)}
							<Card class="w-full max-w-none p-6">
								<div class="mb-4 flex items-center justify-between">
									<h4 class="text-lg font-medium text-gray-900 dark:text-white">
										Kubernetes Resources Status
									</h4>
									<Button
										size="sm"
										color="blue"
										onclick={reconcileFluxResources}
										class="flex items-center gap-2"
									>
										<RefreshOutline class="h-4 w-4" id="reconcile-icon" />
										Reconcile Flux Resources
									</Button>
								</div>

								<div class="space-y-4">
									{#if kustomizations.length > 0 || ociRepositories.length > 0 || (managedResources && Object.keys(managedResources).length > 0)}
										{@const allResources = [
											...kustomizations.map((k) => ({
												name: k.metadata?.name,
												namespace: k.metadata?.namespace,
												status: getResourceStatus(k).status,
												message: k.status?.lastAppliedRevision
													? `Last applied: ${k.status.lastAppliedRevision}`
													: undefined,
												lastModified: getLastTransitionTime(k),
												groupVersionKind: 'Kustomization',
												type: 'Kustomization'
											})),
											...ociRepositories.map((r) => ({
												name: r.metadata?.name,
												namespace: r.metadata?.namespace,
												status: getResourceStatus(r).status,
												message: r.status?.url ? `URL: ${r.status.url}` : undefined,
												lastModified: getLastTransitionTime(r),
												groupVersionKind: 'OCIRepository',
												type: 'OCIRepository'
											})),
											...Object.values(filteredManagedResources)
												.flat()
												.map((r) => ({
													...r,
													type: r.groupVersionKind?.split('/').pop() || 'Resource'
												}))
										]}
										{@const pendingResources = allResources.filter(
											(r) =>
												r.status === 'Failed' ||
												r.status === 'Error' ||
												r.status === 'InProgress' ||
												r.status === 'Pending' ||
												r.status === 'Unhealthy'
										)}
										{@const healthyResources = allResources.filter(
											(r) =>
												r.status === 'Ready' ||
												r.status === 'Healthy' ||
												r.status === 'Succeeded' ||
												r.status === 'Current'
										)}

										{#if pendingResources.length > 0}
											<div>
												{#each pendingResources as resource (resource.type + '/' + (resource.namespace || '') + '/' + resource.name)}
													<ResourceCard {resource} resourceType={resource.type} showRich={true} />
												{/each}
											</div>
										{/if}

										{#if healthyResources.length > 0 && pendingResources.length === 0}
											<div class="flex items-center justify-center py-8">
												<div class="text-center">
													<div class="mb-2 flex items-center justify-center">
														<CheckCircleSolid class="h-8 w-8 text-green-600 dark:text-green-400" />
													</div>
													<p class="text-sm font-medium text-gray-900 dark:text-white">
														All {allResources.length} resources are healthy
													</p>
												</div>
											</div>
										{:else if healthyResources.length > 0}
											<div class="mt-4 rounded-lg bg-green-50 p-3 dark:bg-green-900/20">
												<div class="flex items-center gap-2">
													<CheckCircleSolid class="h-4 w-4 text-green-600 dark:text-green-400" />
													<span class="text-sm font-medium text-green-800 dark:text-green-200">
														{healthyResources.length} out of {allResources.length} resources are healthy
													</span>
												</div>
											</div>
										{/if}
									{/if}
								</div>
							</Card>
						{/if}

						<!-- Available Versions Card -->
						<Card class="w-full max-w-none p-6 lg:col-span-2">
							<div class="mb-4 flex items-center justify-between">
								<h4 class="text-lg font-medium text-gray-900 dark:text-white">
									Available Version Upgrades
								</h4>
								{#if rollout.status?.releaseCandidates && rollout.status.releaseCandidates.length > 0}
									<Badge color="blue" size="small">{rollout.status.releaseCandidates.length}</Badge>
								{/if}
							</div>
							{#if rollout.status?.releaseCandidates && rollout.status.releaseCandidates.length > 0}
								<div>
									{#each rollout.status.releaseCandidates as releaseCandidate}
										{@const version = releaseCandidate.tag}
										<div class="border-b border-gray-200 py-4 last:border-b-0 dark:border-gray-700">
											<div class="flex items-center justify-between">
												<div class="flex items-center gap-3">
													<div class="flex h-8 w-8 items-center justify-center">
														<CodeOutline class="h-5 w-5 text-gray-500 dark:text-gray-400" />
													</div>
													<div class="min-w-0 flex-1">
														<h6 class="truncate text-sm font-medium text-gray-900 dark:text-white">
															{getDisplayVersion(releaseCandidate)}
														</h6>
														{#if releaseCandidate.version && releaseCandidate.version !== version}
															<p class="text-xs text-gray-500 dark:text-gray-400">
																Tag: {version}
															</p>
														{/if}
														{#if releaseCandidate.created}
															<p class="text-xs text-gray-500 dark:text-gray-400">
																Created {formatTimeAgo(releaseCandidate.created, $now)}
															</p>
														{/if}
													</div>
												</div>
												<div class="flex items-center gap-2">
													{#if isVersionForceDeploying(rollout, version)}
														<Badge color="blue" size="small">Gates Skipped</Badge>
													{:else if rollout.status?.gatedReleaseCandidates
														?.map((grc) => grc.tag)
														.includes(version)}
														<Badge color="green" size="small">Available</Badge>
													{:else}
														{@const blockingGates = getBlockingGates(version)}
														{#if blockingGates.length > 0}
															<Badge color="yellow" size="small" class="cursor-help">
																Blocked
																<QuestionCircleOutline class="ml-1 h-3 w-3" />
															</Badge>
															<Popover class="max-w-sm" title="Blocked by Gates">
																<div class="p-3">
																	<div class="space-y-2">
																		{#each blockingGates as gate}
																			<div class="flex items-start gap-2">
																				<ExclamationCircleSolid
																					class="mt-0.5 h-4 w-4 text-yellow-600 dark:text-yellow-400"
																				/>
																				<div class="min-w-0 flex-1">
																					<p
																						class="text-sm font-medium text-gray-900 dark:text-white"
																					>
																						{getGatePrettyName(gate) ||
																							gate.metadata?.name ||
																							'Unknown Gate'}
																					</p>
																					{#if getGateDescription(gate)}
																						<p class="text-xs text-gray-600 dark:text-gray-400">
																							{getGateDescription(gate)}
																						</p>
																					{/if}
																					{#if gate.status?.status}
																						<p class="text-xs text-yellow-600 dark:text-yellow-400">
																							Status: {gate.status.status}
																						</p>
																					{/if}
																				</div>
																			</div>
																		{/each}
																	</div>
																</div>
															</Popover>
														{:else}
															<Badge color="yellow" size="small">Blocked</Badge>
														{/if}
													{/if}
													<Button
														size="xs"
														color="blue"
														disabled={!isDashboardManagingWantedVersion &&
															!hasForceDeployAnnotation(rollout)}
														onclick={() => {
															selectedVersion = version;
															showDeployModal = true;
														}}
													>
														Deploy
													</Button>
													{#if rollout?.status?.source}
														<GitHubViewButton
															sourceUrl={rollout.status.source}
															version={getDisplayVersion(releaseCandidate)}
															size="xs"
															color="light"
														/>
													{/if}
													<Clipboard bind:value={releaseCandidate.tag} size="xs" color="light">
														{#snippet children(success)}
															{#if success}
																<CheckOutline class="mr-1 h-3 w-3" />
																Copied
															{:else}
																<ClipboardCleanSolid class="mr-1 h-3 w-3" />
																Copy Tag
															{/if}
														{/snippet}
													</Clipboard>
												</div>
											</div>
										</div>
									{/each}
								</div>
							{:else if isCurrentVersionCustom}
								<Alert color="yellow">
									<div class="flex items-center gap-3">
										<InfoCircleSolid class="h-5 w-5" />
										<span class="text-lg font-medium">Current version is custom</span>
									</div>
									<p class="mb-4 mt-2 text-sm">
										The currently deployed version is not in the available releases list. This means
										it's a custom version that was manually deployed. To change to a different
										version, you need to manually deploy another version.
									</p>
									<div class="flex gap-2">
										<Button
											size="xs"
											color="light"
											onclick={() => {
												isPinVersionMode = true;
												showPinModal = true;
											}}
										>
											<EditOutline class="me-2 h-4 w-4" />
											Change Version
										</Button>
									</div>
								</Alert>
							{:else}
								<Alert color="blue">
									<div class="flex items-center">
										<ExclamationCircleSolid class="mr-2 h-5 w-5" />
										<span class="font-medium">No version upgrades available</span>
									</div>
								</Alert>
							{/if}
						</Card>
					</div>
				</div>
			</div>
		</div>

		<!-- Timeline Drawer -->
		<Drawer
			bind:open={showTimelineDrawer}
			placement="right"
			class="z-4 w-min min-w-0 overflow-hidden"
		>
			<div class="flex h-full w-full min-w-0 flex-col">
				<div class="flex-shrink-0 border-b border-gray-200 p-4 dark:border-gray-700">
					<div class="flex items-center justify-between">
						<h4 class="text-lg font-medium text-gray-900 dark:text-white">Rollout History</h4>
					</div>
				</div>
				<div class="w-full min-w-0 flex-1 overflow-y-auto overflow-x-hidden p-4 pb-0">
					{#if rollout.status?.history}
						<Timeline order="vertical" class="w-full min-w-0">
							{#each rollout.status.history as entry, i ((entry.version.tag, i))}
								<TimelineItem
									h3Class="font-mono"
									liClass="mr-4 flex flex-col"
									title={getDisplayVersion(entry.version)}
									date="Deployed {formatTimeAgo(entry.timestamp, $now)}"
								>
									{#snippet orientationSlot()}
										<span
											class="absolute -start-3 flex h-6 w-6 items-center justify-center rounded-full bg-white ring-8 ring-white dark:bg-gray-800 dark:ring-gray-800"
										>
											<svelte:component
												this={getBakeStatusIcon(entry.bakeStatus).icon}
												class="h-6 w-6 {getBakeStatusIcon(entry.bakeStatus).color}"
											/>
										</span>
									{/snippet}
									<div class="flex h-full flex-col">
										<!-- Top content -->
										<div class="flex-1">
											<span class="w-full"
												>{#if getRevisionInfo(entry.version)}
													<Badge color="gray" class="mr-1">
														{formatRevision(getRevisionInfo(entry.version)!)}
													</Badge>
												{/if}</span
											>
											{#if entry.message}
												<div class="mb-2 mt-2">
													<Blockquote class="text-xs">
														{entry.message}
													</Blockquote>
												</div>
											{/if}
										</div>

										<!-- Bottom content - buttons and bake status -->
										<div class="mt-auto space-y-2">
											{#if entry.bakeStatus}
												<div class="space-y-1">
													{#if entry.bakeStatusMessage}
														<p class="text-xs text-gray-600 dark:text-gray-400">
															{entry.bakeStatusMessage}
														</p>
													{/if}

													{#if entry.bakeStartTime && entry.bakeEndTime}
														<p class="text-xs text-gray-500 dark:text-gray-500">
															Bake completed in {formatDuration(
																entry.bakeStartTime,
																new Date(entry.bakeEndTime)
															)}
														</p>
													{/if}
												</div>
											{/if}
											<div class="space-y-2 pt-3 dark:border-gray-700">
												{#if rollout?.status?.artifactType === 'application/vnd.cncf.flux.config.v1+json'}
													<SourceViewer
														namespace={rollout.metadata?.namespace || ''}
														name={rollout.metadata?.name || ''}
														version={entry.version.tag}
													/>
												{/if}
												{#if i < rollout.status.history.length - 1 && rollout?.status?.artifactType === 'application/vnd.cncf.flux.config.v1+json'}
													<Button
														color="light"
														size="xs"
														href={`/rollouts/${rollout.metadata?.namespace}/${rollout.metadata?.name}/diff/${entry.version.tag}`}
														class=""
													>
														<CodePullRequestSolid class="mr-1 h-3 w-3" />
														Show diff
													</Button>
												{/if}
												{#if entry.version.tag !== rollout.status?.history[0]?.version.tag}
													<Button
														color="light"
														size="xs"
														onclick={() => {
															// Set up rollback mode
															isPinVersionMode = true;
															selectedVersion = entry.version.tag;
															pinVersionToggle = true;
															// Generate default rollback message
															const currentVersion = rollout?.status?.history?.[0]?.version;
															const targetVersion = entry.version;
															const currentVersionName = currentVersion
																? getDisplayVersion(currentVersion)
																: 'current';
															const targetVersionName = getDisplayVersion(targetVersion);
															deployExplanation = `Rollback from ${currentVersionName} to ${targetVersionName} due to issues with the current deployment.`;
															showDeployModal = true;
														}}
														class=""
													>
														<ReplyOutline class="mr-1 h-3 w-3" />
														Rollback
													</Button>
												{/if}
												{#if rollout?.status?.source}
													<GitHubViewButton
														sourceUrl={rollout.status.source}
														version={getDisplayVersion(entry.version)}
														size="xs"
														color="light"
													/>
												{/if}
												<Clipboard bind:value={entry.version.tag} size="xs" color="light" class="">
													{#snippet children(success)}
														{#if success}
															<CheckOutline class="mr-1 h-3 w-3" />
															Copied
														{:else}
															<ClipboardCleanSolid class="mr-1 h-3 w-3" />
															Copy Tag
														{/if}
													{/snippet}
												</Clipboard>
											</div>
										</div>
									</div>
								</TimelineItem>
							{/each}
						</Timeline>
					{:else}
						<div class="flex h-full items-center justify-center text-gray-500 dark:text-gray-400">
							<p>No deployment history available</p>
						</div>
					{/if}
				</div>
			</div>
		</Drawer>
	{/if}
</div>

<Modal bind:open={showPinModal} title="Pin Version">
	<div class="space-y-4">
		{#if !isDashboardManagingWantedVersion}
			<Alert color="yellow" class="mb-4">
				<ExclamationCircleSolid class="h-4 w-4" />
				<span class="font-medium">Warning:</span> The dashboard is not currently managing the wantedVersion
				field for this rollout. Setting a pin may conflict with other controllers or external systems.
			</Alert>
		{/if}

		<!-- Search and Toggle Section -->
		<div class="space-y-3">
			<div class="flex items-center gap-3">
				<div class="flex-1">
					<input
						type="text"
						placeholder="Search all versions..."
						bind:value={searchQuery}
						class="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm text-gray-900 placeholder-gray-500 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"
					/>
				</div>
				<Toggle
					bind:checked={showAllTags}
					color="blue"
					onchange={() => {
						if (showAllTags && allRepositoryTags.length === 0) {
							getAllRepositoryTags();
						}
						// Reset to first page when switching modes
						currentPage = 1;
					}}
				>
					Show All Versions
				</Toggle>
			</div>
		</div>

		<!-- All Versions Section -->
		<div>
			<h5 class="mb-3 text-sm font-medium text-gray-700 dark:text-gray-300">
				{showAllTags ? 'All Repository Versions' : 'Available Versions'}
				{#if showAllTags}
					<Badge color="gray" class="ml-2 text-xs">
						{filteredVersionsForDisplay.length} total versions
					</Badge>
				{:else if rollout?.status?.availableReleases}
					<Badge color="blue" class="ml-2 text-xs">
						{rollout.status.availableReleases.length} versions
					</Badge>
				{/if}
			</h5>
			<Listgroup active class="max-h-64 overflow-y-auto">
				{#if showAllTags ? filteredVersionsForDisplay.length > 0 : rollout?.status?.availableReleases}
					{#each showAllTags ? paginatedUnifiedVersions : paginatedVersions as version}
						{@const versionTag = typeof version === 'string' ? version : version.tag}
						{#if searchQuery === '' || versionTag.toLowerCase().includes(searchQuery.toLowerCase())}
							{@const _clipboard = clipboardValue = versionTag}
							{#await loadAnnotationsOnDemand(versionTag)}{/await}
							<ListgroupItem
								onclick={() => {
									selectedVersion = versionTag;
								}}
								class="w-full cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700 {selectedVersion ===
								versionTag
									? 'border-2 border-blue-300 bg-blue-50 dark:border-blue-600 dark:bg-blue-900'
									: 'border-2 border-transparent'}"
							>
								<div class="flex w-full items-center justify-between">
									<div class="flex-1 space-y-2 pr-4">
										<div class="flex items-center justify-between">
											<div class="flex-1">
												<div class="font-medium text-gray-900 dark:text-white">
													{#if loadingAnnotations[versionTag]}
														<div
															class="h-5 w-32 animate-pulse rounded bg-gray-200 dark:bg-gray-700"
														></div>
													{:else}
														{(() => {
															// Check if this is a regular release in availableReleases
															const availableRelease = rollout?.status?.availableReleases?.find(
																(ar) => ar.tag === versionTag
															);
															if (availableRelease) {
																return getDisplayVersion(availableRelease);
															}
															// Fall back to annotations for custom releases
															return getDisplayVersion({
																version:
																	annotations[versionTag]?.['org.opencontainers.image.version'],
																tag: versionTag
															});
														})()}
													{/if}
												</div>
												{#if (() => {
													const availableRelease = rollout?.status?.availableReleases?.find((ar) => ar.tag === versionTag);
													const version = availableRelease?.version || annotations[versionTag]?.['org.opencontainers.image.version'];
													return version && version !== versionTag;
												})()}
													<div class="text-xs text-gray-500 dark:text-gray-400">
														Tag: <code
															class="rounded bg-gray-100 px-1 py-0.5 text-xs dark:bg-gray-800"
															>{versionTag}</code
														>
													</div>
												{/if}
											</div>
										</div>

										<!-- Version details -->
										<div class="grid grid-cols-2 gap-4 text-xs text-gray-600 dark:text-gray-400">
											{#if loadingAnnotations[versionTag]}
												<div class="col-span-2 space-y-2">
													<div
														class="h-4 w-20 animate-pulse rounded bg-gray-200 dark:bg-gray-700"
													></div>
													<div
														class="h-3 w-16 animate-pulse rounded bg-gray-200 dark:bg-gray-700"
													></div>
												</div>
											{:else}
												{#if (() => {
													const availableRelease = rollout?.status?.availableReleases?.find((ar) => ar.tag === versionTag);
													return availableRelease?.created || annotations[versionTag]?.['org.opencontainers.image.created'];
												})()}
													<div>
														<span class="font-medium">Created:</span>
														<div class="mb-1">
															{formatDate(
																(() => {
																	const availableRelease = rollout?.status?.availableReleases?.find(
																		(ar) => ar.tag === versionTag
																	);
																	return (
																		availableRelease?.created ||
																		annotations[versionTag]?.['org.opencontainers.image.created']
																	);
																})()
															)}
														</div>
														<div class="text-gray-500 dark:text-gray-500">
															<Badge color="gray" border>
																<ClockSolid class="me-1.5 h-2.5 w-2.5" />
																{formatTimeAgo(
																	(() => {
																		const availableRelease =
																			rollout?.status?.availableReleases?.find(
																				(ar) => ar.tag === versionTag
																			);
																		return (
																			availableRelease?.created ||
																			annotations[versionTag]?.['org.opencontainers.image.created']
																		);
																	})(),
																	$now
																)}
															</Badge>
														</div>
													</div>
												{/if}
												{#if (() => {
													const availableRelease = rollout?.status?.availableReleases?.find((ar) => ar.tag === versionTag);
													return availableRelease?.revision || annotations[versionTag]?.['org.opencontainers.image.revision'];
												})()}
													<div>
														<span class="font-medium">Revision:</span>
														<div class="font-mono">
															{formatRevision(
																(() => {
																	const availableRelease = rollout?.status?.availableReleases?.find(
																		(ar) => ar.tag === versionTag
																	);
																	return (
																		availableRelease?.revision ||
																		annotations[versionTag]?.['org.opencontainers.image.revision']
																	);
																})()!
															)}
														</div>
													</div>
												{/if}
											{/if}
										</div>

										<!-- Status indicators -->
										<div class="flex flex-wrap gap-2">
											{#if rollout?.status?.history?.[0]?.version.tag === versionTag}
												<Badge color="green" class="text-xs">
													<CheckCircleSolid class="mr-1 h-3 w-3" />
													Currently Deployed
												</Badge>
											{/if}
											{#if rollout?.spec?.wantedVersion === versionTag}
												<Badge class="text-xs">
													<CheckCircleSolid class="mr-1 h-3 w-3" />
													Currently Pinned
												</Badge>
											{/if}
											{#if showAllTags && !rollout?.status?.availableReleases
													?.map((ar) => ar.tag)
													.includes(versionTag)}
												<Badge color="yellow" class="text-xs">
													<ExclamationCircleSolid class="mr-1 h-3 w-3" />
													Custom
												</Badge>
											{/if}
										</div>

										<!-- Action buttons -->
										<div class="flex gap-2 pt-2">
											{#if loadingAnnotations[versionTag]}
												<div class="flex gap-2">
													<div
														class="h-6 w-20 animate-pulse rounded bg-gray-200 dark:bg-gray-700"
													></div>
													<div
														class="h-6 w-16 animate-pulse rounded bg-gray-200 dark:bg-gray-700"
													></div>
												</div>
											{:else}
												{#if rollout?.status?.source}
													<GitHubViewButton
														sourceUrl={rollout.status.source}
														version={(() => {
															const availableRelease = rollout?.status?.availableReleases?.find(
																(ar) => ar.tag === versionTag
															);
															if (availableRelease) {
																return getDisplayVersion(availableRelease);
															}
															return getDisplayVersion({
																version:
																	annotations[versionTag]?.['org.opencontainers.image.version'],
																tag: versionTag
															});
														})()}
														size="xs"
														color="light"
													/>
												{/if}
												<Clipboard bind:value={clipboardValue} size="xs" color="light" class="">
													{#snippet children(success)}
														{#if success}
															<CheckOutline class="mr-1 h-3 w-3" />
															Copied
														{:else}
															<ClipboardCleanSolid class="mr-1 h-3 w-3" />
															Copy Tag
														{/if}
													{/snippet}
												</Clipboard>
											{/if}
										</div>
									</div>
									<div class="w-6 flex-shrink-0">
										{#if selectedVersion === versionTag}
											<CheckCircleSolid class="h-5 w-5 text-blue-600 dark:text-blue-400" />
										{/if}
									</div>
								</div>
							</ListgroupItem>
						{/if}
					{/each}
				{:else}
					<ListgroupItem class="text-center text-gray-500 dark:text-gray-400">
						No versions available
					</ListgroupItem>
				{/if}
			</Listgroup>
		</div>

		<div class="flex justify-end gap-2 pt-4">
			{#if (showAllTags ? totalUnifiedPages : totalPages) > 1}
				<div class="flex flex-1 items-center justify-center gap-2">
					<Button
						size="sm"
						color="light"
						onclick={() => goToPage(currentPage - 1)}
						disabled={currentPage === 1}
					>
						Previous
					</Button>
					<span class="text-sm text-gray-600 dark:text-gray-400">
						Page {currentPage} of {showAllTags ? totalUnifiedPages : totalPages}
					</span>
					<Button
						size="sm"
						color="light"
						onclick={() => goToPage(currentPage + 1)}
						disabled={currentPage === (showAllTags ? totalUnifiedPages : totalPages)}
					>
						Next
					</Button>
				</div>
			{/if}
			<Button
				color="light"
				onclick={() => {
					showPinModal = false;
					selectedVersion = null;
					searchQuery = '';
					showAllTags = false;
					isPinVersionMode = false;
				}}
			>
				Cancel
			</Button>
			<Button
				color="blue"
				disabled={!selectedVersion}
				onclick={() => {
					if (isPinVersionMode) {
						// In pin version mode, open deploy modal with toggle disabled and set to pin
						pinVersionToggle = true;
						showDeployModal = true;
						showPinModal = false;
					} else {
						// Original behavior for other contexts - this should not happen anymore
						// since we're using the unified deploy modal
						console.warn('Unexpected call to old confirmation modal');
					}
				}}
			>
				Pin Version
			</Button>
		</div>
	</div>
</Modal>

<Modal bind:open={showClearPinModal} title="Clear Pin">
	<div class="space-y-4">
		{#if !isDashboardManagingWantedVersion}
			<Alert color="yellow" class="mb-4">
				<ExclamationCircleSolid class="h-4 w-4" />
				<span class="font-medium">Warning:</span> The dashboard is not currently managing the wantedVersion
				field for this rollout. Clearing the pin may conflict with other controllers or external systems.
			</Alert>
		{/if}
		<p class="text-sm text-gray-600 dark:text-gray-400">
			Are you sure you want to clear the version pin for {rollout?.metadata?.name}?
		</p>
		<div class="flex justify-end gap-2">
			<Button
				color="light"
				onclick={() => {
					showClearPinModal = false;
				}}
			>
				Cancel
			</Button>
			<Button color="blue" onclick={clearPin}>Clear Pin</Button>
		</div>
	</div>
</Modal>

<Modal bind:open={showResumeRolloutModal} title="Confirm Resume Rollout">
	<div class="space-y-4">
		<Alert color="yellow" class="mb-4">
			<div class="flex items-center">
				<ExclamationCircleSolid class="mr-2 h-4 w-4" />
				<p>
					<span class="font-medium">Warning:</span> This will resume the rollout process after a failed
					deployment bake.
				</p>
			</div>
		</Alert>
		<p class="text-sm text-gray-600 dark:text-gray-400">
			Are you sure you want to resume the rollout for <b>{rollout?.metadata?.name}</b>?
		</p>
		<p class="text-xs text-gray-500 dark:text-gray-400">
			This will add the unblock-failed annotation to allow the rollout controller to resume
			deployment of the failed version.
		</p>
		<div class="flex justify-end gap-2">
			<Button
				color="light"
				onclick={() => {
					showResumeRolloutModal = false;
					selectedVersion = null;
				}}
			>
				Cancel
			</Button>
			<Button color="blue" onclick={resumeRollout}>
				<PlaySolid class="mr-1 h-3 w-3" />
				Resume Rollout
			</Button>
		</div>
	</div>
</Modal>

<Modal bind:open={showMarkSuccessfulModal} title="Mark Deployment as Successful">
	<div class="space-y-4">
		<Alert color="green" class="mb-4">
			<div class="flex items-center">
				<CheckCircleSolid class="mr-2 h-4 w-4" />
				<p>
					<span class="font-medium">Mark as Successful:</span> This will mark the failed deployment as
					successful and update the deployment history.
				</p>
			</div>
		</Alert>
		<p class="text-sm text-gray-600 dark:text-gray-400">
			Are you sure you want to mark the deployment for <b>{rollout?.metadata?.name}</b> as successful?
		</p>
		<p class="text-xs text-gray-500 dark:text-gray-400">
			This will update the deployment history to show the deployment as succeeded and set the bake
			end time to now.
		</p>
		<Alert color="blue" class="mt-3">
			<div class="flex items-center">
				<InfoCircleSolid class="mr-2 h-4 w-4" />
				<p class="text-sm">
					<span class="font-medium">Alternative:</span> You can also deploy a different version to fix
					the deployment issue instead of marking this one as successful.
				</p>
			</div>
		</Alert>

		<!-- Message field -->
		<div>
			<label
				for="mark-successful-message"
				class="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300"
			>
				Message (Optional)
			</label>
			<textarea
				id="mark-successful-message"
				bind:value={markSuccessfulMessage}
				placeholder="Provide additional details about why you're marking this deployment as successful..."
				class="w-full rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm text-gray-900 placeholder-gray-500 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-blue-500 dark:focus:ring-blue-500"
				rows="3"
			></textarea>
		</div>

		<div class="flex justify-end gap-2">
			<Button
				color="light"
				onclick={() => {
					showMarkSuccessfulModal = false;
					markSuccessfulMessage = '';
				}}
			>
				Cancel
			</Button>
			<Button color="green" onclick={() => markDeploymentSuccessful(markSuccessfulMessage)}>
				<CheckCircleSolid class="mr-1 h-3 w-3" />
				Mark Successful
			</Button>
		</div>
	</div>
</Modal>

<DeployModal
	bind:open={showDeployModal}
	{rollout}
	selectedVersionTag={selectedVersion}
	{selectedVersionDisplay}
	{isPinVersionMode}
	onSuccess={(m) => {
		toastType = 'success';
		toastMessage = m;
		showToast = true;
		setTimeout(() => (showToast = false), 3000);
	}}
	onError={(m) => {
		toastType = 'error';
		toastMessage = m;
		showToast = true;
		setTimeout(() => (showToast = false), 3000);
	}}
/>

<Toast
	transition={fly}
	position="top-right"
	params={{ x: 200 }}
	class="fixed right-4 top-24 z-50 rounded-lg"
	align={false}
	bind:toastStatus={showToast}
>
	{#snippet icon()}
		<div
			class="inline-flex h-8 w-8 shrink-0 items-center justify-center rounded-lg {toastType ===
			'success'
				? 'bg-green-100 text-green-500 dark:bg-green-800 dark:text-green-200'
				: 'bg-red-100 text-red-500 dark:bg-red-800 dark:text-red-200'}"
		>
			{#if toastType === 'success'}
				<CheckCircleSolid class="h-5 w-5" />
			{:else}
				<ExclamationCircleSolid class="h-5 w-5" />
			{/if}
		</div>
	{/snippet}
	{toastMessage}
</Toast>

<style>
</style>
